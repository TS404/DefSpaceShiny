{
    "collab_server" : "",
    "contents" : "\n# This is the server logic for a Shiny web application.\n# You can find out more about building applications with Shiny here:\n#\n# http://shiny.rstudio.com\n#\n\n# Import necessary files ----------------------------------------------------------------------\nlibrary(shiny)\nlibrary(\"rgl\")\nlibrary(\"ggplot2\")\nlibrary(\"Biostrings\")\nlibrary(\"DECIPHER\")\nlibrary(\"mclust\")\nlibrary(\"tidyr\")\n\nfolder    <- \"C:\\\\Users\\\\T\\\\OneDrive\\\\1-Scripts\\\\GitHub\\\\DefSpaceShiny\"\nsetwd(folder)\n\nSAPCA.cis <- readRDS(\"data\\\\CisDef.reference.PCA.RDS\")\nSAPCA.tra <- readRDS(\"data\\\\TransDef.reference.PCA.RDS\")\n\nview.cis <- readRDS(\"data\\\\CisDef.viewangle.RDS\")\nview.tra <- readRDS(\"data\\\\TransDef.viewangle.RDS\")\n\nBLOSUM40 <- readRDS(\"data\\\\BLOSUM.RDS\")\n\nmotifs <- readRDS(\"data\\\\cysteine_motifs.RDS\")\n\nclusters.cis=c(\"'extreme' plant antimicrobial defensins\",  #1\n               \"mostly plant antimicrobial defensins\",     #2\n               \"proteins with a mixture of functions from across the eukarya\", #3\n               \"plant signalling proteins\",                #4\n               \"plant histidine-rich defensins\",           #5\n               \"arthropod antimicrobial defensins\",        #6\n               \"arthropod alpha neurotoxins\")              #7\n\nclusters.tra=c(\"theta defensins\", #1\n               \"alpha defensins\", #2\n               \"beta defensins\",  #3\n               \"big defensins\")   #4\n\n# Outputs -------------------------------------------------------------------------\n\nshinyServer(function(input, output) {\n\n    # Calculations when 'Show' button pressed ---------------------  \n  DATA.view <- eventReactive(input$button.view,{\n    \n    if(input$view_type==\"cis-Defensin\"){\n      match        <- \"cis-Defensin\"\n      SAPCA.match  <- SAPCA.cis\n      newseq.match <- newseq.cis\n      view         <- view.cis\n      plotPCs      <- c(1,2,3)\n    }else{\n      match        <- \"trans-Defensin\"\n      SAPCA.match  <- SAPCA.tra\n      newseq.match <- newseq.tra\n      view         <- view.tra\n      plotPCs      <- c(2,1,4)\n    }\n    \n    # data variables list\n    list(match        = match,\n         SAPCA.match  = SAPCA.match,\n         newseq.match = newseq.match,\n         view         = view,\n         plotPCs      = plotPCs,\n         empty        = \"\")\n  })\n  \n # Calculations when 'Calculate' button pressed ---------------------\n  DATA <- eventReactive(input$button,{\n    \n    # Remove line breaks from fasta input\n    query_seq <- gsub(\"(>.*?)\\n\",\"\\\\1<\\n\",input$query_sequence)\n    query_seq <- gsub(\"([^<])\\n([^>])\",\"\\\\1\\\\2\",query_seq)\n    query_seq <- gsub(\"<\\n\",\"\\n\",query_seq)\n    # Ignore all but first input sequence and remove fasta headings\n    query_seq <- gsub(\"(\\n){2,100}\",\"\\n\",query_seq)\n    query_seq <- gsub(\"\\n.*\",\"\",gsub(\">.*?\\n\",\"\",query_seq))\n    \n    # Superfamily match\n    newseq.cis <- seq.MSA.add(SAPCA.cis,query_seq,\"cis-Defensins\")\n    newseq.tra <- seq.MSA.add(SAPCA.tra,query_seq,\"trans-Defensins\")\n    \n    if(input$query_type==\"cis-Defensin\" |\n       input$query_type==\"unknown\" & newseq.cis$aln.hit.score >= newseq.tra$aln.hit.score){\n        match        <- \"cis-Defensin\"\n        SAPCA.match  <- SAPCA.cis\n        newseq.match <- newseq.cis\n        view         <- view.cis\n        plotPCs      <- c(1,2,3)\n    }else if(input$query_type==\"trans-Defensin\" |\n             input$query_type==\"unknown\" & newseq.cis$aln.hit.score <= newseq.tra$aln.hit.score){\n        match        <- \"trans-Defensin\"\n        SAPCA.match  <- SAPCA.tra\n        newseq.match <- newseq.tra\n        view         <- view.tra\n        plotPCs      <- c(1,2,4)\n    }\n\n    temp.seq  <- gsub(\"subject: |[[]1]| \",\"\",capture.output(newseq.match$seq.unalignable)[3])\n    newseq.r  <- seq.rotate    (SAPCA.match, newseq.match)\n    newseq.c  <- seq.clust.add (SAPCA.match, newseq.r)\n    SAPCA.add <- seq.SAPCA.add (SAPCA.match, newseq.r, newseq.c)\n    \n    if(match==\"cis-Defensin\"){\n       clust.name   <- clusters.cis[SAPCA.add$seq.space.clusters$classification[1]]\n    }else if(match==\"trans-Defensin\"){\n       clust.name   <- clusters.tra[SAPCA.add$seq.space.clusters$classification[1]]\n    }\n    \n    # Motif match\n    motif.matches <- NULL\n    for(m in 1:nrow(motifs)){\n      motif.match <- length(grep(as.character(motifs[m,2]),\n                            as.character(as.AAstring(query_seq,degap=1)),\n                            ignore.case = 1))==1\n      motif.matches <- append(motif.matches,motif.match)\n    }\n    \n    if(all(motif.matches==0)){\n      motif.short <- print(\"No strict matches\")\n      motif       <- print(\"It does not strictly match any defensin motif\")\n    }else{\n      motif.short <- paste(as.character(motifs[motif.matches,1]),collapse = \" and \")\n      motif       <- paste0(\"It contains the \",\n                            paste(as.character(motifs[motif.matches,1]),collapse = \" and \"),\n                            \" cysteine motif\")\n    }\n    \n    # data variables list\n    list(match         = match,\n         motif         = motif,\n         motif.short   = motif.short,\n         SAPCA.match   = SAPCA.match,\n         newseq.match  = newseq.match,\n         newseq.cis    = newseq.cis,\n         newseq.tra    = newseq.tra,\n         view          = view,\n         plotPCs       = plotPCs,\n         clust.name    = clust.name,\n         temp.seq      = temp.seq,\n         SAPCA.add     = SAPCA.add,\n         empty         = \"\")\n    \n  })\n  \n  \n  \n  \n  DATA2.view <- eventReactive(input$button2.view,{\n    \n    list(selected.view = plot_overlay_3Dlabel.A(SAPCA   = DATA.view()$SAPCA.match,\n                                                plotPCs = DATA.view()$plotPCs),\n         go = TRUE)\n    \n  })\n  \n  \n  DATA2 <- eventReactive(input$button2,{\n    \n    list(selected = plot_overlay_3Dlabel.A(SAPCA   = DATA()$SAPCA.add,\n                                           plotPCs = DATA()$plotPCs),\n         go = TRUE)\n    \n  })\n\n  \n  \n\n  # Plot seqspace (view) -------------------------------------\n  output$mainplot.view <- renderPlot({\n    \n    # plot(DATA.view()$plotPCs)\n    if(DATA.view()$match==\"cis-Defensin\"){\n      colours<-palette(c(\"blue\",            #1 Plant extreme\n                         \"darkolivegreen4\", #2 Plant main\n                         \"grey\",            #3 Intermed\n                         \"purple1\",         #4 Plant sex\n                         \"orange\",          #5 Plant his\n                         \"maroon\",          #6 Invert\n                         \"red\"))            #7 Tox\n    }\n    if(DATA.view()$match==\"trans-Defensin\"){\n      colours<-palette(c(\"blue\",     #1 Theta\n                         \"red\",      #2 Aalpha\n                         \"orange\",   #3 Beta\n                         \"purple\"))  #4\n    }\n    \n\n    plot_3Dclusters(DATA.view()$SAPCA.match,\n                    plotPCs = DATA.view()$plotPCs)\n    rgl::rgl.viewpoint(180,-70)\n    # rgl::par3d(DATA()$view)\n    \n    if(DATA2.view()$go){\n      plot_overlay_3Dlabel.B(selection = DATA2.view()$selected.view,\n                             SAPCA     = DATA.view()$SAPCA.match,\n                             plotPCs   = DATA.view()$plotPCs)\n    }\n    \n  })\n  \n  # Plot seqspace (query) -------------------------------------\n  output$mainplot <- renderPlot({\n\n    # plot(DATA()$plotPCs)\n    if(DATA()$match==\"cis-Defensin\"){\n      colours<-palette(c(\"blue\",            #1 Plant extreme\n                         \"darkolivegreen4\", #2 Plant main\n                         \"grey\",            #3 Intermed\n                         \"purple1\",         #4 Plant sex\n                         \"orange\",          #5 Plant his\n                         \"maroon\",          #6 Invert\n                         \"red\"))            #7 Tox\n    }\n    if(DATA()$match==\"trans-Defensin\"){\n      colours<-palette(c(\"blue\",     #1 Theta\n                         \"red\",      #2 Aalpha\n                         \"orange\",   #3 Beta\n                         \"purple\"))  #4\n    }\n\n    \n\n    plot_3Dclusters(DATA()$SAPCA.add,\n                    plotPCs = DATA()$plotPCs,\n                    labels = \"query\",\n                    radius = c(2,rep(0.3,nrow(DATA()$SAPCA.add$numerical.alignment$MSA)-1)))\n    rgl::rgl.viewpoint(180,-70)\n    # rgl::par3d(DATA()$view)\n    \n    if(DATA2()$go){\n      plot_overlay_3Dlabel.B(selection = DATA2()$selected,\n                             SAPCA     = DATA()$SAPCA.add,\n                             plotPCs   = DATA()$plotPCs)\n    }\n           \n  })\n  \n  # output$histplot <- renderPlot({\n  #   \n  #   aln.cis <- DATA()$newseq.cis$aln.all.score\n  #   aln.tra <- DATA()$newseq.tra$aln.all.score\n  #   \n  #   aln.cis[aln.cis<=0]<-0\n  #   aln.tra[aln.tra<=0]<-0\n  #   \n  #   aln.cistra <- c(aln.cis,\n  #                   aln.tra)\n  #   \n  #   max <- min(10,max(c(hist(aln.cis,(0:40)/40,plot = 0)$density,\n  #                       hist(aln.tra,(0:40)/40,plot = 0)$density)))\n  #   \n  #   hist(aln.cis,\n  #        xlim   = c(0,1),\n  #        ylim   = c(0,max),\n  #        breaks = (0:40)/40,\n  #        col    = rgb(0,0.5,0,0.5), # green\n  #        freq   = FALSE,\n  #        xlab   = \"Similarity\",\n  #        main   = \"\")\n  #   hist(aln.tra,\n  #        breaks = (0:40)/40,\n  #        col    = rgb(0,0,0.8,0.5), # blue\n  #        freq   = FALSE,\n  #        add    = TRUE)\n  #   box()\n  # })\n  \n  # Text report on match ------------------------------------\n  # Superfamily type and best hit\n  \n  output$report_legend <- renderText({\n    \n    paste (\"blue:\",\"'extreme' plant antimicrobial defensins.\",    #1\n           \"green:\",\"plant antimicrobial defensins.\",      #2\n           \"grey:\",\"proteins with a mixture of functions from across the eukarya.\", #3\n           \"purple:\",\"plant signalling proteins.\",                #4\n           \"orange:\",\"plant histidine-rich defensins.\",           #5\n           \"maroon:\",\"arthropod antimicrobial defensins.\",        #6\n           \"red:\",\"arthropod alpha neurotoxins.\"                  #7\n          )\n  })\n  \n  output$title <- renderText({\n\n    paste0(\"Results summary\",\n           DATA()$empty)\n    \n  })\n  \n  output$report <- renderText({\n    \n    # Report section 1\n    rep1 <- if(input$query_type==\"unknown\"){\n              if(quantile(DATA()$newseq.match$aln.all.score, 0.95)>=0.15){\n                print(paste0(\"The submitted query sequence is more likely to be from the \",\n                             DATA()$match,\n                             \" superfamily. \",\n                             DATA()$motif,\n                             \". Its similarity to the nearest sequence is \",\n                             percent(DATA()$newseq.match$aln.hit.score),\n                             \".\"))\n              }else{\n                print(paste0(\"The query sequence may not be a defensin. Although defensin sequences are highly variable, the query is a very poor match to any defensin in the database. Therefore, please interpret any of this data with caution. \",\n                             DATA()$motif,\n                             \". Its similarity to any known defensin is only \",\n                             percent(DATA()$newseq.match$aln.hit.score),\n                             \".\"))\n              }\n            }\n\n  # Report section 2\n    rep2 <- paste0(\"The sequence falls within cluster \",\n                   DATA()$SAPCA.add$seq.space.clusters$classification[1],\n                   \", which contains \",\n                   DATA()$clust.name,\n                   \".\")\n    \n  # Report section 3\n    exceptions <- if(sum(strsplit(DATA()$temp.seq,\"\")[[1]]==\"-\")!=0){\n      paste0(\", except for \",\n             sum(strsplit(DATA()$temp.seq,\"\")[[1]]==\"-\"),\n             \". The residues that were taken into account in calculating its sequence space position were therefore: '\",\n             DATA()$temp.seq,\n             \"'\")\n    }\n    \n    rep3 <- paste0(\"All residues of the query sequence were alignable to the existing \",\n                   DATA()$match,\n                   \" MSA\",\n                   exceptions,\n                   \".\")\n\n  # join the report sentences together into paragraph\n  paste(rep1,rep2,rep3)\n  })\n\n  \n  # Nearest neighbours fasta alignment\n  output$fasta <- renderUI({\n    \n    HTML(\n      as.fasta(DATA()$SAPCA.add$numerical.alignment$MSA[rownames(closest(DATA()$SAPCA.add,n = 1+input$return_nearest,\"query\")),],\n               decolgap = TRUE,\n               print    = TRUE)\n    )\n  })\n  \n  \n  # Selected sequences fasta alignment\n  output$fasta2 <- renderUI({\n    \n    HTML(\n      as.fasta(DATA()$SAPCA.add$numerical.alignment$MSA[DATA2()$selected$selected.set,],\n               decolgap = TRUE,\n               print    = TRUE)\n    )\n  })\n  \n  \n  # Selected sequences fasta alignment\n  output$fasta2.view <- renderUI({\n    \n    HTML(\n      as.fasta(DATA.view()$SAPCA.match$numerical.alignment$MSA[DATA2.view()$selected$selected.set,],\n               decolgap = TRUE,\n               print    = TRUE)\n    )\n  })\n  \n  DATA.table <- eventReactive(input$button,{\n    \n    #Summary table\n    summary.table <- data.frame(cbind(c(\"Superfamily\",\n                                        \"Cysteine motifs\",\n                                        \"Max similarity\",\n                                        \"SeqSpace cluster\",\n                                        \"Cluster functions\",\n                                        \"Unalignable residues\"),\n                                      c(if(quantile(DATA()$newseq.match$aln.all.score, 0.95)>=0.15){\n                                        DATA()$match\n                                        }else{\n                                          paste0(\"May not be a defensin (\",\n                                                 DATA()$match,\n                                                 \" is best match)\")\n                                        },\n                                        DATA()$motif.short,\n                                        percent(DATA()$newseq.match$aln.hit.score),\n                                        DATA()$SAPCA.add$seq.space.clusters$classification[1],\n                                        DATA()$clust.name,\n                                        sum(strsplit(DATA()$temp.seq,\"\")[[1]]==\"-\"))\n    ))\n    colnames(summary.table)<- c(\"Property\",\"Result\")\n    summary.table\n  })\n  \n  output$table <- renderTable(DATA.table())\n  \n})\n\n\n# Functions ------------------------------------------------------------------------------\n\nnumericise_MSA <- function(MSA,\n                           res.prop,\n                           cys){\n  seq.names <- rownames(MSA)\n  aln.len   <- ncol(MSA)\n  res.props <- colnames(res.prop)\n  res.avail <- row.names(res.prop)\n  # Numericise MSA based on res.prop\n  MSA.num.tall <- res.prop[t(MSA),]\n  # Name data types\n  rownames(MSA.num.tall) <- NULL\n  sequence     <- rep(x = seq.names, each  = aln.len)\n  residue      <- rep(x = 1:aln.len, times = length(seq.names))\n  MSA.num.tall <- cbind(sequence, residue, MSA.num.tall)\n  # Stack data into list of matrices\n  MSA.num.stack <- NULL\n  for (x in 1:length(res.props)) {\n    col.names <- paste(1:aln.len,\n                       rep(res.props[x],aln.len),\n                       sep = \".\")\n    MSA.num.stack[[res.props[x]]] <- matrix(MSA.num.tall[,x+2],\n                                            ncol     = aln.len,\n                                            byrow    = TRUE,\n                                            dimnames = list(seq.names,\n                                                            col.names))\n  }\n  # Also reflow into single wide matrix\n  MSA.num.wide <- MSA.num.stack[[1]]\n  for (x in 2:length(res.props)) {\n    MSA.num.wide <- cbind(MSA.num.wide, MSA.num.stack[[res.props[x]]])\n  }\n  \n  \n  ############################.\n  # Scaling by property type #\n  ############################.\n  \n  # Take means and variances of each property type\n  prop.means <- NULL\n  prop.vars  <- NULL\n  for (x in 1:length(res.props)) {\n    prop.means[x] <- mean(MSA.num.stack[[x]],na.rm=1)\n    prop.vars[x]  <- var(tidyr::gather(data.frame(MSA.num.stack[[x]]))[2],na.rm=1)\n  }\n  names(prop.means) <- res.props\n  names(prop.vars)  <- res.props\n  \n  # Scale numericised MSA to prop.means and prop.vars\n  MSA.scale.stack <- NULL\n  for (x in 1:length(res.props)) {\n    MSA.scale.stack[[res.props[x]]] <- (MSA.num.stack[[res.props[x]]]- prop.means[x]) /\n      sqrt(prop.vars[x])\n  }\n  \n  # Replace gaps (currently \"NA\") with column average\n  # Create na.colmean function\n  na.colmean<-function(x){\n    x[is.na(x)] <- mean(as.matrix(x),na.rm = 1)\n    x\n  }\n  # For each property of MSA.num.stack, apply na.colmean function to each matrix comlumn\n  for (x in 1:length(res.props)) {\n    MSA.scale.stack[[x]] <- apply(MSA.scale.stack[[x]],2,na.colmean)\n  }\n  \n  # Also reflow into singe wide matrix for PCA\n  MSA.scale.wide <- MSA.scale.stack[[1]]\n  for (x in 2:length(res.props)) {\n    MSA.scale.wide <- cbind(MSA.scale.wide, MSA.scale.stack[[x]])\n  }\n  \n  \n  ##################.\n  # Alignment list #\n  ##################.\n  \n  numerical.alignment <- list(MSA             = MSA,\n                              res.prop        = res.prop,\n                              MSA.num.stack   = MSA.num.stack,\n                              MSA.num.wide    = MSA.num.wide,\n                              MSA.scale.stack = MSA.scale.stack,\n                              MSA.scale.wide  = MSA.scale.wide,\n                              prop.means      = prop.means,\n                              prop.vars       = prop.vars,\n                              seq.names       = seq.names,\n                              aln.len         = aln.len)\n  numerical.alignment\n}\n\n\n\nclosest <- function (SAPCA,\n                     sequence,\n                     PC = 1:3,\n                     n  = 10){\n  \n  coords     <- SAPCA$seq.space.PCA$coordinates\n  centre     <- coords[sequence,PC]\n  centre.m   <- matrix(rep(centre,nrow(coords)),\n                       nrow  = nrow(coords),\n                       byrow = TRUE)\n  distances  <- SAPCA$seq.space.PCA$coordinates[,PC]-centre.m\n  rootsquare <- sqrt(rowSums(distances^2))\n  \n  sorted     <- as.matrix(rootsquare[order(rootsquare)])\n  colnames(sorted) <- \"distance\"\n  \n  head(sorted,n)\n}\n\n\n\nread.MSA <- function(MSA){\n  # Load sequence MSA\n  # if a matrix, can be used straight away\n  # if raw fasta file, use seqinr to convert to data frame\n  if (!is.matrix(MSA)){\n    MSA       <- data.frame(seqinr::read.fasta(MSA,set.attributes=FALSE))\n  }\n  # if a data frame, convert to matrix\n  if (is.data.frame(MSA)){\n    MSA       <- as.matrix(t(toupper(as.matrix(MSA))))\n  }\n  \n  MSA\n}\n\n\n\nas.fasta <- function(matrix,degap=FALSE,decolgap=FALSE,write=FALSE,print=FALSE,name=NULL){\n  \n  # Remove empty columns\n  if(decolgap){\n    matrix<-matrix[,colMeans(matrix==\"-\")!=1]\n  }\n  \n  # Convert alignment matrix to list of strings\n  names <- paste(\">\",row.names(matrix),sep=\"\")\n  seqs  <- do.call(\"paste\",c(data.frame(matrix),sep=\"\"))\n  \n  # If just one sequence, this is how to name it\n  if(is.null(dim(matrix))){\n    names <- \">sequence\"\n    if(!is.null(name)){\n      names <- paste(\">\",name,sep=\"\")\n    }\n    seqs  <- paste(matrix,collapse=\"\")\n  }\n  \n  # Degap sequences\n  if (degap){\n    seqs <- gsub(\"-\",\"\",seqs)\n  }\n  \n  # Interleave names and sequences\n  ord1 <- 2*(1:length(names))-1\n  ord2 <- 2*(1:length(seqs))\n  \n  # Output\n  if (print==TRUE){\n    paste0(c(names,seqs)[order(c(ord1,ord2))], sep = \"<br/>\")\n  }else{\n    if (write==FALSE){\n      cat(c(names,seqs)[order(c(ord1,ord2))], sep = \"\\n\")\n    }\n    else{\n      if (!grepl(\".fa\",write,ignore.case=TRUE)){\n        write<-paste(write,\".fa\",sep=\"\")\n      }\n      cat(c(names,seqs)[order(c(ord1,ord2))], sep = \"\\n\", file = write)\n    }\n  }\n}\n\n\n\nas.AAstring<-function(string, degap=FALSE){\n  string <- paste(string,collapse=\"\")\n  if(degap==TRUE){\n    string<-gsub(\"-\",\"\",string)\n  }\n  output <- Biostrings::AAString(string)\n  output\n}\n\n\nas.AAstringSet<-function(MSA, degap=FALSE){\n  MSA <- apply(MSA,1,paste,collapse=\"\")\n  if(degap==TRUE){\n    MSA<-gsub(\"-\",\"\",MSA)\n  }\n  output <- Biostrings::AAStringSet(MSA)\n  output\n}\n\n\n\nseq.MSA.add <- function(SAPCA,sequence,SAPCAname=NULL,smatrix=BLOSUM40){\n  sequence <- casefold(sequence,upper=TRUE)\n  MSA   <- SAPCA$numerical.alignment$MSA\n  MSA2  <- as.AAstringSet(MSA,degap = TRUE)\n  seqs  <- nrow(MSA)\n  seq   <- as.AAstring(sequence, degap=FALSE)\n  seq.d <- as.AAstring(sequence, degap=TRUE)\n  BLOSUM40 <- smatrix\n  \n  aln.all <- Biostrings::pairwiseAlignment(MSA2,\n                                           seq.d,\n                                           substitutionMatrix = BLOSUM40,\n                                           gapOpening   = 0,\n                                           gapExtension = 4,\n                                           scoreOnly    = TRUE)\n  \n  # Max possible similarity score\n  aln.limit <- Biostrings::pairwiseAlignment(seq.d,\n                                             seq.d,\n                                             substitutionMatrix = BLOSUM40,\n                                             gapOpening   = 0,\n                                             gapExtension = 4,\n                                             scoreOnly    = TRUE)\n  \n  # Similarity score as percentage of max\n  aln.hit.score <- max(aln.all)/aln.limit\n  \n  # The sequence of the best matching member of the database\n  aln.hit.num  <- which(aln.all==max(aln.all))[1]\n  aln.hit.name <- SAPCA$numerical.alignment$seq.names[aln.hit.num]\n  aln.hit.seq  <- paste(as.AAstring(MSA[aln.hit.num,],degap = 1))\n  \n  # Use \"*\" to indicate gaps in the best reference sequence (aln.hit)\n  aln.hit <- gsub(\"-\",\"*\",as.AAstring(MSA[aln.hit.num,]))\n  \n  # Use \"#\" to anchor ends of sequences so that they are not trimmed\n  aln.hit.anchor <- paste0(\"########\",aln.hit,\"########\")\n  seq.d.anchor   <- paste0(\"########\",seq.d,  \"########\")\n  \n  aln.add <- Biostrings::pairwiseAlignment(aln.hit.anchor,\n                                           seq.d.anchor,\n                                           substitutionMatrix = BLOSUM40,\n                                           gapOpening   = 0,\n                                           gapExtension = 4)\n  \n  # Has the new sequence introduced exrta gaps into the hit sequence alignement?\n  aln.hit.orig         <- as.AAstring(MSA[aln.hit.num,])\n  aln.hit.new          <- gsub(\"#\",\"\",Biostrings::pattern(aln.add))\n  aln.hit.seq.aln.orig <- unlist(strsplit(as.character(aln.hit.orig),\"\"))\n  aln.hit.seq.aln.new  <- unlist(strsplit(as.character(aln.hit.new),\"\"))\n  \n  if(as.character(aln.hit.orig)!=as.character(aln.hit.new)){\n    print(paste(sum(aln.hit.seq.aln.new==\"-\"),\n                \"residues of the new sequence were not alignable to the\",\n                SAPCAname,\n                \"reference MSA so were ignored\"))\n  }\n  \n  # Alignment addition as matrix\n  aln.add.mat <- rbind(unlist(strsplit(as.character(gsub(\"#\",\"\",Biostrings::pattern(aln.add))),\"\")),\n                       unlist(strsplit(as.character(gsub(\"#\",\"\",Biostrings::subject(aln.add))),\"\")))\n  \n  # Unmathcable resiues removed from aligned sequence\n  aln.add2 <- aln.add.mat[2,][aln.add.mat[1,]!=\"-\"]\n  aln.add3 <- paste(as.AAstring(aln.add2))\n\n  # Unalignable residues ignored from the middle of the sequence\n  \n  seq.alignable <- Biostrings::pairwiseAlignment(seq.d,\n                                                 as.AAstring(aln.add3, degap=TRUE),\n                                                 substitutionMatrix = BLOSUM40,\n                                                 gapOpening   = 0,\n                                                 gapExtension = 4)\n  # res.mid.removed <- sum(unlist(strsplit(as.character(subject(seq.alignable)),\"\"))==\"-\")\n  # \n  # # Reidues removed from the start or finish template (aln.hit) during alignment\n  # res.terminal.discrep <- nchar(gsub(\"[*]\",\"\",aln.hit)) - nchar(gsub(\"[*]\",\"\",aln.hit.new)) + res.mid.removed\n  # \n  # aln.hit.d <- unlist(strsplit(as.character(gsub(\"[*]\",\"\",aln.hit)),\"\"))\n  # aln.hit.new.d <- unlist(strsplit(as.character(gsub(\"[*]\",\"\",aln.hit.new)),\"\"))\n  # \n  # aln.hit.d[x + 1:length(aln.hit.new.d)]\n  # \n  # displacement <- NULL\n  # for(x in 0:(res.terminal.discrep)){\n  #   displacement <- append(displacement,mean(aln.hit.d[x + 1:length(aln.hit.new.d)]==aln.hit.new.d))\n  # }\n  # res.lead.missing <- which.max(displacement)-1\n  # res.tail.missing <- res.terminal.discrep-which.max(displacement)+1\n  # \n  # # Gaps in the hit sequence (original and newly aligned)\n  # gaps.orig       <- unlist(strsplit(as.character(aln.hit.orig),\"[A-Z]\"))\n  # gaps.count.orig <- nchar(gaps.orig)\n  # gaps.lead.orig  <- gaps.count.orig[1]\n  # gaps.tail.orig  <- gaps.count.orig[length(gaps.count.orig)]\n  # \n  # gaps.new        <- unlist(strsplit(as.character(gsub(\"-\",\"\",aln.hit.new)),\"[A-Z]\"))\n  # gaps.count.new  <- nchar(gaps.new)\n  # gaps.lead.new   <- gaps.count.new[1]\n  # gaps.tail.new   <- gaps.count.new[length(gaps.count.new)]\n  # \n  # if(length(gaps.count.orig)>length(gaps.count.new)){\n  #   gaps.count.new <- append(gaps.count.new,0)\n  # }\n  # \n  # gaps.discrep     <- rbind(gaps.count.orig,\n  #                            c(rep(0,res.lead.missing),gaps.count.new))\n  # gaps.discrep.num <- gaps.discrep[1,]-gaps.discrep[2,]\n  # gaps.lead.add    <- gaps.discrep.num[1] + res.lead.missing\n  # gaps.tail.add    <- gaps.discrep.num[length(gaps.discrep.num)] + res.tail.missing\n\n  # # Final aligned sequence to add (with gps at beginning and end to fit)\n  # query <- c(rep(\"-\",gaps.lead.add),\n  #            aln.add2,\n  #            rep(\"-\",gaps.tail.add))\n  \n  query <- aln.add2\n  \n  aln.final <- rbind(query,MSA)\n  output    <- list(MSA             = aln.final,\n                    aln.hit.name    = aln.hit.name,\n                    aln.hit.seq     = aln.hit.seq,\n                    aln.hit.score   = aln.hit.score,\n                    aln.all.score   = aln.all/aln.limit,\n                    seq.unalignable = seq.alignable)\n  output\n}\n\n\n\nseq.rotate <- function(SAPCA,newseq){\n  \n  res.props  <- colnames(SAPCA$numerical.alignment$res.prop)\n  prop.means <- SAPCA$numerical.alignment$prop.means\n  prop.vars  <- SAPCA$numerical.alignment$prop.vars\n  # Align new sequence with MSA\n  \n  # Numericise new sequence\n  newseq.num <- numericise_MSA(MSA      = newseq$MSA[c(\"query\",newseq$aln.hit.name),],\n                               res.prop = SAPCA$numerical.alignment$res.prop)\n  \n  # Scale new sequnce using same scaling as SAPCA (gaps as \"NA\")\n  newseq.scale.stack <- NULL\n  for (x in 1:length(res.props)) {\n    newseq.scale.stack[[res.props[x]]] <- (newseq.num$MSA.num.stack[[res.props[x]]]- prop.means[x]) /\n      sqrt(prop.vars[x])\n  }\n  \n  # Reflow into single wide matrix\n  newseq.scale.wide <- newseq.scale.stack[[1]]\n  for (x in 2:length(res.props)) {\n    newseq.scale.wide <- cbind(newseq.scale.wide, newseq.scale.stack[[res.props[x]]])\n  }\n  \n  # Replace gaps (currently \"NA\") with column average of the scaled SAPCA\n  # Create na.colmean function\n  gapvalues  <- colMeans(SAPCA$numerical.alignment$MSA.scale.wide)\n  na.replace <- function(x,y){\n    x[is.na(x)] <- y\n    x\n  }\n  newseq.scale.wide.g <- NULL\n  for(i in 1:ncol(newseq.scale.wide)){\n    newseq.scale.wide.g <- cbind(newseq.scale.wide.g,\n                                 na.replace(newseq.scale.wide[,i],gapvalues[i]))\n  }\n  \n  # Rotate scaled sequence into same space as SAPCA\n  newseq.rot <- scale(newseq.scale.wide.g,\n                      SAPCA$seq.space.PCA$centre,\n                      SAPCA$seq.space.PCA$scale) %*% SAPCA$seq.space.PCA$loadings\n  \n  # Output\n  output <- list(seq       = newseq,\n                 seq.num   = newseq.num$MSA.num.wide,\n                 seq.scale = newseq.scale.wide.g,\n                 seq.rot   = newseq.rot)\n  output\n}\n\n\n\nseq.clust.add <- function(SAPCA,newseq.r){\n  \n  SAPCA.c  <- mclustrev(SAPCA)\n  newseq.c <- mclust::predict.Mclust(SAPCA.c,newseq.r$seq.rot[,SAPCA$call$clusterPCs])\n  newseq.c\n}\n\n\n\nmclustrev <- function(SAPCA){\n  output <- SAPCA$seq.space.clusters$other\n  \n  output$classification <- SAPCA$seq.space.clusters$classification\n  output$G              <- SAPCA$seq.space.clusters$optimal\n  output$z              <- SAPCA$seq.space.clusters$likelihoods\n  \n  class(output) <- \"Mclust\"\n  output\n}\n\n\n\nseq.SAPCA.add <- function (SAPCA,newseq.r,newseq.c){\n  output <- SAPCA\n  output$numerical.alignment$seq.names      <- rownames(newseq.r$seq$MSA)\n  output$numerical.alignment$MSA            <- newseq.r$seq$MSA\n  output$numerical.alignment$MSA.num.wide   <- rbind(newseq.r$seq.num[1,],\n                                                     SAPCA$numerical.alignment$MSA.num.wide)\n  output$numerical.alignment$MSA.scale.wide <- rbind(newseq.r$seq.scale[1,],\n                                                     SAPCA$numerical.alignment$MSA.scale.wide)\n  output$numerical.alignment$MSA.num.stack  <- NULL\n  output$numerical.alignment$MSA.scale.stack<- NULL\n  \n  output$seq.space.PCA$coordinates          <- rbind(newseq.r$seq.rot[1,],\n                                                     SAPCA$seq.space.PCA$coordinates)\n  output$seq.space.clusters$likelihoods     <- rbind(newseq.c$z[1,],\n                                                     SAPCA$seq.space.clusters$likelihoods)\n  output$seq.space.clusters$classification  <- c(newseq.c$classification[1],\n                                                 SAPCA$seq.space.clusters$classification)\n  \n  rownames(output$numerical.alignment$MSA.num.wide)[1]   <- \"query\"\n  rownames(output$numerical.alignment$MSA.scale.wide)[1] <- \"query\"\n  rownames(output$seq.space.PCA$coordinates)[1]          <- \"query\"\n  rownames(output$seq.space.clusters$likelihoods)[1]     <- \"query\"\n  \n  output\n}\n\n\n\nseq.add.full <- function (SAPCA,sequence,SAPCAname=NULL){\n  \n  newseq   <- seq.MSA.add(SAPCA,sequence,SAPCAname)\n  newseq.r <- seq.rotate(SAPCA,newseq)\n  newseq.c <- seq.clust.add(SAPCA,newseq.r)\n  SAPCA2   <- seq.SAPCA.add(SAPCA,newseq.r,newseq.c)\n  \n  SAPCA2\n}\n\n\n\npercent <- function(x, digits = 1, format = \"f\", ...) {\n  paste0(formatC(100 * x, format = format, digits = digits, ...), \"%\")\n}\n\n\n\nplot_3Dclusters <- function(SAPCA,\n                            plotPCs    = 1:3,\n                            col        = \"cluster\",\n                            radius     = 1,\n                            labels     = NULL,\n                            write      = FALSE,\n                            axeslabels = \"default\"){\n  if (!is.null(SAPCA$seq.space.PCA$coordinates)){\n    data <- SAPCA$seq.space.PCA$coordinates\n  }else{\n    data <- SAPCA    \n  }\n  \n  if (all(col==\"cluster\")){\n    colour <- SAPCA$seq.space.clusters$classification\n  }else{\n    colour <- col\n  }\n  # Calculate radius size\n  rad <- (range(SAPCA$seq.space.PCA$coordinates[,plotPCs])[2]-range(SAPCA$seq.space.PCA$coordinates[,plotPCs])[1])/100\n  rad <- rad*radius\n  \n  if (all(axeslabels==\"default\")){\n    axes <- paste(\"PC\",plotPCs,sep=\"\")\n  }else{\n    axes <- axeslabels\n  }\n  if (is.null(axeslabels)){\n    axes <- c(\"\",\"\",\"\")\n  }\n  \n  # Plot model-based clusters in 3D\n  rgl::plot3d(data[,plotPCs],\n              col      = colour,      # colour by clusters\n              specular = \"black\",     # matte lighting\n              type     = \"s\",         # \"p\" is points, \"s\" is spheres\n              radius   = rad,         # sphere radius if using spheres\n              size     = 4,           # point size\n              axes     = FALSE,       # draw axes separately\n              xlab     = axes[1],\n              ylab     = axes[2],\n              zlab     = axes[3])       \n  # Draw axes\n  if (write!=FALSE){\n    rgl::axes3d(color = \"black\", labels = FALSE)                       \n  }else{\n    rgl::axes3d(color = \"black\", alpha=0.5, labels = FALSE) \n  }\n  \n  for (NAME in labels){\n    SUB = row.names(SAPCA$seq.space.PCA$coordinates)==NAME      # Label based on its row.name\n    rgl::text3d(subset(SAPCA$seq.space.PCA$coordinates[,plotPCs],subset=SUB), \n                text      = paste('---',NAME),   # data label text\n                font      = 2,                   # bold\n                color     = \"black\",             # colour\n                adj       = -rad/2)              # offset\n  }\n  \n  # Write html for interactive data\n  if (write!=FALSE){\n    rglwidget::.writeWebGL(write)                          \n  }\n}\n\n\n\nplot_overlay_3Dlabel.A <- function(SAPCA,\n                                   plotPCs = 1:3){\n  selected     <- rgl::select3d()\n  selected.set <- selected(SAPCA$seq.space.PCA$coordinates[,plotPCs])\n \n  list(selected     = selected,\n       selected.set = selected.set)\n}\n\n\nplot_overlay_3Dlabel.B <- function(selection,\n                                   SAPCA,\n                                   plotPCs = 1:3){\n  selected     <- selection$selected\n  selected.set <- selection$selected.set\n  \n  if(sum(selected.set)!=0){\n    as.fasta(SAPCA$numerical.alignment$MSA[selected.set,],\n             decolgap=TRUE)\n    \n    \n    for (NAME in SAPCA$numerical.alignment$seq.names[selected.set]){\n      # Which point will be labelled\n      SUB <- NAME   \n      # What is the label text\n      TEXT <- NAME\n      \n      rad <- (range(SAPCA$seq.space.PCA$coordinates[,plotPCs])[2] -\n                range(SAPCA$seq.space.PCA$coordinates[,plotPCs])[1]) /\n        100\n      \n      rgl::text3d(SAPCA$seq.space.PCA$coordinates[SUB,plotPCs], \n                  text      = paste('---',TEXT),   # data label text\n                  font      = 2,                   # bold\n                  color     = \"black\",             # colour\n                  adj       = -rad/2)              # offset\n    }\n  }\n}\n",
    "created" : 1503466720886.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3950472477",
    "id" : "446926CA",
    "lastKnownWriteTime" : 1503289424,
    "last_content_update" : 1503289424,
    "path" : "C:/Users/T/OneDrive/1-Scripts/GitHub/DefSpaceShiny/server.R",
    "project_path" : "server.R",
    "properties" : {
        "docOutlineSize" : "120",
        "docOutlineVisible" : "1"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}