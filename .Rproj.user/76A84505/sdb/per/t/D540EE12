{
    "collab_server" : "",
    "contents" : "\n# This is the server logic for a Shiny web application.\n# You can find out more about building applications with Shiny here:\n#\n# http://shiny.rstudio.com\n#\n\n# Import necessary files ----------------------------------------------------------------------\nlibrary(shiny)\nlibrary(\"rgl\")\nlibrary(\"ggplot2\")\nlibrary(\"Biostrings\")\nlibrary(\"DECIPHER\")\nlibrary(\"mclust\")\n\nfolder    <- \"C:\\\\Users\\\\T\\\\OneDrive\\\\1-Scripts\\\\GitHub\\\\DefSpace\"\nsetwd(folder)\n\nSAPCA.cis <- readRDS(\"data\\\\CisDef.reference.PCA.RDS\")\nSAPCA.tra <- readRDS(\"data\\\\TransDef.reference.PCA.RDS\")\n\nview.cis <- readRDS(\"data\\\\CisDef.viewangle.RDS\")\nview.tra <- readRDS(\"data\\\\TransDef.viewangle.RDS\")\n\nBLOSUM40 <- readRDS(\"data\\\\BLOSUM.RDS\")\n\nclusters.cis=c(\"'extreme' plant antimicrobial defensins\",  #1\n               \"mostly plant antimicrobial defensins\",     #2\n               \"proteins with a mixture of functions from across the eukarya\", #3\n               \"plant signalling proteins\",                #4\n               \"plant histidine-rich defensins\",           #5\n               \"arthropod antimicrobial defensins\",        #6\n               \"arthropod alpha neurotoxins\")              #7\n\nclusters.tra=c(\"theta defensins\", #1\n               \"alpha defensins\", #2\n               \"beta defensins\",  #3\n               \"big defensins\")   #4\n\n# Outputs -------------------------------------------------------------------------\n\nshinyServer(function(input, output) {\n  \n  # Calculations when button pressed\n  DATA <- eventReactive(input$button,{\n    \n    newseq.cis <- seq.MSA.add(SAPCA.cis,input$query_sequence,\"cis-Defensins\")\n    newseq.tra <- seq.MSA.add(SAPCA.tra,input$query_sequence,\"trans-Defensins\")\n    \n    if(input$query_type==\"cis-Defensin\" |\n       input$query_type==\"unknown\" & newseq.cis$aln.hit.score >= newseq.tra$aln.hit.score){\n        match        <- \"cis-Defensin\"\n        SAPCA.match  <- SAPCA.cis\n        newseq.match <- newseq.cis\n        view         <- view.cis\n        plotPCs      <- c(1,2,3)\n    }else if(input$query_type==\"trans-Defensin\" |\n             input$query_type==\"unknown\" & newseq.cis$aln.hit.score <= newseq.tra$aln.hit.score){\n        match        <- \"trans-Defensin\"\n        SAPCA.match  <- SAPCA.tra\n        newseq.match <- newseq.tra\n        view         <- view.tra\n        plotPCs      <- c(1,2,4)\n    }\n\n    temp.seq  <- gsub(\"subject: |[[]1]| \",\"\",capture.output(newseq.match$seq.unalignable)[3])\n    newseq.r  <- seq.rotate    (SAPCA.match, newseq.match)\n    newseq.c  <- seq.clust.add (SAPCA.match, newseq.r)\n    SAPCA.add <- seq.SAPCA.add (SAPCA.match, newseq.r, newseq.c)\n    \n    if(match==\"cis-Defensin\"){\n       clust.name   <- clusters.cis[SAPCA.add$seq.space.clusters$classification[1]]\n    }else if(match==\"trans-Defensin\"){\n       clust.name   <- clusters.tra[SAPCA.add$seq.space.clusters$classification[1]]\n    }\n    \n    # data variables list\n    DATA <- list(match        = match,\n                 SAPCA.match  = SAPCA.match,\n                 newseq.match = newseq.match,\n                 view         = view,\n                 plotPCs      = plotPCs,\n                 clust.name   = clust.name,\n                 temp.seq     = temp.seq,\n                 SAPCA.add    = SAPCA.add)\n    DATA\n  })\n  \n  # Main seqspace plot\n  output$mainplot <- renderPlot({\n  \n    # plot(DATA()$plotPCs)\n    if(DATA()$match==\"cis-Defensin\"){\n      colours<-palette(c(\"blue\",            #1 Plant extreme\n                         \"darkolivegreen4\", #2 Plant main\n                         \"grey\",            #3 Intermed\n                         \"purple1\",         #4 Plant sex\n                         \"orange\",          #5 Plant his\n                         \"maroon\",          #6 Invert\n                         \"red\"))            #7 Tox\n    }\n    if(DATA()$match==\"trans-Defensin\"){\n      colours<-palette(c(\"blue\",     #1 Theta\n                         \"red\",      #2 Aalpha\n                         \"orange\",   #3 Beta\n                         \"purple\"))  #4\n    }\n\n    plot_3Dclusters(DATA()$SAPCA.add,\n                    plotPCs = DATA()$plotPCs,\n                    labels = \"query\",\n                    radius = c(2,rep(0.3,nrow(DATA()$SAPCA.add$numerical.alignment$MSA)-1)))\n \n  })\n  \n  #####TEMP\n  output$temp <- renderText({print(   DATA()$temp.seq  )})\n  ####\n  \n  # Report on match\n  # Superfamily type and best hit\n  output$report <- renderText({\n   \n    if(input$query_type==\"unknown\"){\n      if(quantile(DATA()$newseq.match$aln.all.score, 0.95)>=0.15){\n        print(paste0(\"The submitted query sequence appears to be a \",\n                     DATA()$match,\n                     \". Its similarity to the nearest sequence is \",\n                     percent(DATA()$newseq.match$aln.hit.score),\n                     \".\"))\n      }else{\n        print(paste0(\"Sequence may not be a defensin. Its similarity to any known defensin is only \",\n                     percent(DATA()$newseq.match$aln.hit.score),\n                     \".\"))\n      }\n    }\n  })\n  \n  # Matching residues\n  output$report2 <- renderText({\n    \n    exceptions <- if(sum(strsplit(DATA()$temp.seq,\"\")[[1]]==\"-\")!=0){\n                     paste0(\", except for \",\n                            sum(strsplit(DATA()$temp.seq,\"\")[[1]]==\"-\"),\n                            \". The residues that were taken into account in calculating its sequence space position were therefore: '\",\n                            DATA()$temp.seq,\n                            \"'\")\n                   }\n    \n    paste0(\"All residues of the query sequence were alignable to the existing \",\n           DATA()$match,\n           \" MSA\",\n           exceptions,\n           \".\")\n  })\n  \n  # Cluster\n  output$report3 <- renderText({\n    \n    paste0(\"The sequence falls within cluster \",\n           DATA()$SAPCA.add$seq.space.clusters$classification[1],\n           \", which contains \",\n           DATA()$clust.name)\n  })\n  \n  # Nearest neighbours fasta alignment\n  output$fasta <- renderUI({\n    \n    HTML(\n      as.fasta(DATA()$SAPCA.add$numerical.alignment$MSA[rownames(closest(DATA()$SAPCA.add,n = input$return_nearest,\"query\")),],\n               decolgap = TRUE,\n               print    = TRUE)\n    )\n  })\n  \n})\n\n\n# Functions ------------------------------------------------------------------------------\n\nnumericise_MSA <- function(MSA,\n                           res.prop,\n                           cys){\n  seq.names <- rownames(MSA)\n  aln.len   <- ncol(MSA)\n  res.props <- colnames(res.prop)\n  res.avail <- row.names(res.prop)\n  # Numericise MSA based on res.prop\n  MSA.num.tall <- res.prop[t(MSA),]\n  # Name data types\n  rownames(MSA.num.tall) <- NULL\n  sequence     <- rep(x = seq.names, each  = aln.len)\n  residue      <- rep(x = 1:aln.len, times = length(seq.names))\n  MSA.num.tall <- cbind(sequence, residue, MSA.num.tall)\n  # Stack data into list of matrices\n  MSA.num.stack <- NULL\n  for (x in 1:length(res.props)) {\n    col.names <- paste(1:aln.len,\n                       rep(res.props[x],aln.len),\n                       sep = \".\")\n    MSA.num.stack[[res.props[x]]] <- matrix(MSA.num.tall[,x+2],\n                                            ncol     = aln.len,\n                                            byrow    = TRUE,\n                                            dimnames = list(seq.names,\n                                                            col.names))\n  }\n  # Also reflow into single wide matrix\n  MSA.num.wide <- MSA.num.stack[[1]]\n  for (x in 2:length(res.props)) {\n    MSA.num.wide <- cbind(MSA.num.wide, MSA.num.stack[[res.props[x]]])\n  }\n  \n  \n  ############################.\n  # Scaling by property type #\n  ############################.\n  \n  # Take means and variances of each property type\n  prop.means <- NULL\n  prop.vars  <- NULL\n  for (x in 1:length(res.props)) {\n    prop.means[x] <- mean(MSA.num.stack[[x]],na.rm=1)\n    prop.vars[x]  <- var(tidyr::gather(data.frame(MSA.num.stack[[x]]))[2],na.rm=1)\n  }\n  names(prop.means) <- res.props\n  names(prop.vars)  <- res.props\n  \n  # Scale numericised MSA to prop.means and prop.vars\n  MSA.scale.stack <- NULL\n  for (x in 1:length(res.props)) {\n    MSA.scale.stack[[res.props[x]]] <- (MSA.num.stack[[res.props[x]]]- prop.means[x]) /\n      sqrt(prop.vars[x])\n  }\n  \n  # Replace gaps (currently \"NA\") with column average\n  # Create na.colmean function\n  na.colmean<-function(x){\n    x[is.na(x)] <- mean(as.matrix(x),na.rm = 1)\n    x\n  }\n  # For each property of MSA.num.stack, apply na.colmean function to each matrix comlumn\n  for (x in 1:length(res.props)) {\n    MSA.scale.stack[[x]] <- apply(MSA.scale.stack[[x]],2,na.colmean)\n  }\n  \n  # Also reflow into singe wide matrix for PCA\n  MSA.scale.wide <- MSA.scale.stack[[1]]\n  for (x in 2:length(res.props)) {\n    MSA.scale.wide <- cbind(MSA.scale.wide, MSA.scale.stack[[x]])\n  }\n  \n  \n  ##################.\n  # Alignment list #\n  ##################.\n  \n  numerical.alignment <- list(MSA             = MSA,\n                              res.prop        = res.prop,\n                              MSA.num.stack   = MSA.num.stack,\n                              MSA.num.wide    = MSA.num.wide,\n                              MSA.scale.stack = MSA.scale.stack,\n                              MSA.scale.wide  = MSA.scale.wide,\n                              prop.means      = prop.means,\n                              prop.vars       = prop.vars,\n                              seq.names       = seq.names,\n                              aln.len         = aln.len)\n  numerical.alignment\n}\n\n\n\nclosest <- function (SAPCA,\n                     sequence,\n                     PC = 1:3,\n                     n  = 10){\n  \n  coords     <- SAPCA$seq.space.PCA$coordinates\n  centre     <- coords[sequence,PC]\n  centre.m   <- matrix(rep(centre,nrow(coords)),\n                       nrow  = nrow(coords),\n                       byrow = TRUE)\n  distances  <- SAPCA$seq.space.PCA$coordinates[,PC]-centre.m\n  rootsquare <- sqrt(rowSums(distances^2))\n  \n  sorted     <- as.matrix(rootsquare[order(rootsquare)])\n  colnames(sorted) <- \"distance\"\n  \n  head(sorted,n)\n}\n\n\n\nas.fasta <- function(matrix,degap=FALSE,decolgap=FALSE,write=FALSE,print=FALSE,name=NULL){\n  \n  # Remove empty columns\n  if(decolgap){\n    matrix<-matrix[,colMeans(matrix==\"-\")!=1]\n  }\n  \n  # Convert alignment matrix to list of strings\n  names <- paste(\">\",row.names(matrix),sep=\"\")\n  seqs  <- do.call(\"paste\",c(data.frame(matrix),sep=\"\"))\n  \n  # If just one sequence, this is how to name it\n  if(is.null(dim(matrix))){\n    names <- \">sequence\"\n    if(!is.null(name)){\n      names <- paste(\">\",name,sep=\"\")\n    }\n    seqs  <- paste(matrix,collapse=\"\")\n  }\n  \n  # Degap sequences\n  if (degap){\n    seqs <- gsub(\"-\",\"\",seqs)\n  }\n  \n  # Interleave names and sequences\n  ord1 <- 2*(1:length(names))-1\n  ord2 <- 2*(1:length(seqs))\n  \n  # Output\n  if (print==TRUE){\n    paste0(c(names,seqs)[order(c(ord1,ord2))], sep = \"<br/>\")\n  }else{\n    if (write==FALSE){\n      cat(c(names,seqs)[order(c(ord1,ord2))], sep = \"\\n\")\n    }\n    else{\n      if (!grepl(\".fa\",write,ignore.case=TRUE)){\n        write<-paste(write,\".fa\",sep=\"\")\n      }\n      cat(c(names,seqs)[order(c(ord1,ord2))], sep = \"\\n\", file = write)\n    }\n  }\n}\n\n\n\nas.AAstring<-function(string, degap=FALSE){\n  string <- paste(string,collapse=\"\")\n  if(degap==TRUE){\n    string<-gsub(\"-\",\"\",string)\n  }\n  output <- Biostrings::AAString(string)\n  output\n}\n\n\nas.AAstringSet<-function(MSA, degap=FALSE){\n  MSA <- apply(MSA,1,paste,collapse=\"\")\n  if(degap==TRUE){\n    MSA<-gsub(\"-\",\"\",MSA)\n  }\n  output <- Biostrings::AAStringSet(MSA)\n  output\n}\n\n\n\nseq.MSA.add <- function(SAPCA,sequence,SAPCAname=NULL){\n  MSA   <- SAPCA$numerical.alignment$MSA\n  MSA2  <- as.AAstringSet(MSA,degap = TRUE)\n  seqs  <- nrow(MSA)\n  seq   <- as.AAstring(sequence, degap=FALSE)\n  seq.d <- as.AAstring(sequence, degap=TRUE)\n  BLOSUM40 <- blosum()\n  \n  aln.all <- Biostrings::pairwiseAlignment(MSA2,\n                                           seq.d,\n                                           substitutionMatrix = BLOSUM40,\n                                           gapOpening   = 0,\n                                           gapExtension = 8,\n                                           scoreOnly    = TRUE)\n  \n  # Max possible similarity score\n  aln.limit <- Biostrings::pairwiseAlignment(seq.d,\n                                             seq.d,\n                                             substitutionMatrix = BLOSUM40,\n                                             gapOpening   = 0,\n                                             gapExtension = 8,\n                                             scoreOnly    = TRUE)\n  \n  # Similarity score as percentage of max\n  aln.hit.score <- max(aln.all)/aln.limit\n  \n  # The sequence of the best matching member of the database\n  aln.hit.num  <- which(aln.all==max(aln.all))[1]\n  aln.hit.name <- SAPCA$numerical.alignment$seq.names[aln.hit.num]\n  aln.hit.seq  <- paste(as.AAstring(MSA[aln.hit.num,],degap = 1))\n  \n  # Use \"*\" to indicate gaps in the best reference sequence (aln.hit)\n  aln.hit <- gsub(\"-\",\"*\",as.AAstring(MSA[aln.hit.num,]))\n  aln.add <- Biostrings::pairwiseAlignment(aln.hit,\n                                           seq.d,\n                                           substitutionMatrix = BLOSUM40,\n                                           gapOpening   = 0,\n                                           gapExtension = 8)\n  \n  # Has the new sequence introduced exrta gaps into the hit sequence alignement?\n  aln.hit.orig         <- as.AAstring(MSA[aln.hit.num,])\n  aln.hit.new          <- Biostrings::pattern(aln.add)\n  aln.hit.seq.aln.orig <- unlist(strsplit(as.character(aln.hit.orig),\"\"))\n  aln.hit.seq.aln.new  <- unlist(strsplit(as.character(aln.hit.new),\"\"))\n  \n  if(as.character(aln.hit.orig)!=as.character(aln.hit.new)){\n    print(paste(sum(aln.hit.seq.aln.new==\"-\"),\n                \"residues of the new sequence were not alignable to the\",\n                SAPCAname,\n                \"reference MSA so were ignored\"))\n  }\n  \n  # Alignment addition as matrix\n  aln.add.mat <- rbind(unlist(strsplit(as.character(Biostrings::pattern(aln.add)),\"\")),\n                       unlist(strsplit(as.character(Biostrings::subject(aln.add)),\"\")))\n  \n  # Unmathcable resiues removed from aligned sequence\n  aln.add2 <- aln.add.mat[2,][aln.add.mat[1,]!=\"-\"]\n  aln.add3 <- paste(as.AAstring(aln.add2))\n  \n  # Gaps in the hit sequence (original and newly aligned)\n  gaps.orig       <- unlist(strsplit(as.character(aln.hit.orig),\"[A-Z]\"))\n  gaps.count.orig <- nchar(gaps.orig)\n  gaps.lead.orig  <- gaps.count.orig[1]\n  gaps.trail.orig <- gaps.count.orig[length(gaps.count.orig)]\n  \n  gaps.new        <- unlist(strsplit(as.character(gsub(\"-\",\"\",aln.hit.new)),\"[A-Z]\"))\n  gaps.count.new  <- nchar(gaps.new)\n  gaps.lead.new   <- gaps.count.new[1]\n  gaps.trail.new  <- gaps.count.new[length(gaps.count.new)]\n  \n  if(length(gaps.count.orig)>length(gaps.count.new)){\n    gaps.count.new <- append(gaps.count.new,0)\n  }\n  \n  gaps.discrep     <- suppressWarnings(rbind(gaps.count.orig,gaps.count.new))\n  gaps.discrep.num <- gaps.discrep[1,]-gaps.discrep[2,]\n  gaps.lead.add    <- gaps.discrep.num[1]\n  gaps.trail.add   <- gaps.discrep.num[length(gaps.discrep.num)]\n  \n  # New alignment\n  aln.add4  <- c(rep(\"-\",gaps.lead.add),\n                 aln.add2,\n                 rep(\"-\",gaps.trail.add))\n  \n  seq.alignable <- Biostrings::pairwiseAlignment(seq.d,\n                                                 as.AAstring(aln.add3, degap=TRUE),\n                                                 substitutionMatrix = BLOSUM40,\n                                                 gapOpening   = 0,\n                                                 gapExtension = 8)\n  length(aln.add4)==ncol(MSA)\n  \n  query     <- aln.add4\n  \n  aln.final <- rbind(query,MSA)\n  output    <- list(MSA             = aln.final,\n                    aln.hit.name    = aln.hit.name,\n                    aln.hit.seq     = aln.hit.seq,\n                    aln.hit.score   = aln.hit.score,\n                    aln.all.score   = aln.all/aln.limit,\n                    seq.unalignable = seq.alignable)\n  output\n}\n\n\n\nseq.rotate <- function(SAPCA,newseq){\n  \n  res.props  <- colnames(SAPCA$numerical.alignment$res.prop)\n  prop.means <- SAPCA$numerical.alignment$prop.means\n  prop.vars  <- SAPCA$numerical.alignment$prop.vars\n  # Align new sequence with MSA\n  \n  # Numericise new sequence\n  newseq.num <- numericise_MSA(MSA      = newseq$MSA[c(\"query\",newseq$aln.hit.name),],\n                               res.prop = SAPCA$numerical.alignment$res.prop)\n  \n  # Scale new sequnce using same scaling as SAPCA (gaps as \"NA\")\n  newseq.scale.stack <- NULL\n  for (x in 1:length(res.props)) {\n    newseq.scale.stack[[res.props[x]]] <- (newseq.num$MSA.num.stack[[res.props[x]]]- prop.means[x]) /\n      sqrt(prop.vars[x])\n  }\n  \n  # Reflow into single wide matrix\n  newseq.scale.wide <- newseq.scale.stack[[1]]\n  for (x in 2:length(res.props)) {\n    newseq.scale.wide <- cbind(newseq.scale.wide, newseq.scale.stack[[res.props[x]]])\n  }\n  \n  # Replace gaps (currently \"NA\") with column average of the scaled SAPCA\n  # Create na.colmean function\n  gapvalues  <- colMeans(SAPCA$numerical.alignment$MSA.scale.wide)\n  na.replace <- function(x,y){\n    x[is.na(x)] <- y\n    x\n  }\n  newseq.scale.wide.g <- NULL\n  for(i in 1:ncol(newseq.scale.wide)){\n    newseq.scale.wide.g <- cbind(newseq.scale.wide.g,\n                                 na.replace(newseq.scale.wide[,i],gapvalues[i]))\n  }\n  \n  # Rotate scaled sequence into same space as SAPCA\n  newseq.rot <- scale(newseq.scale.wide.g,\n                      SAPCA$seq.space.PCA$centre,\n                      SAPCA$seq.space.PCA$scale) %*% SAPCA$seq.space.PCA$loadings\n  \n  # Output\n  output <- list(seq       = newseq,\n                 seq.num   = newseq.num$MSA.num.wide,\n                 seq.scale = newseq.scale.wide.g,\n                 seq.rot   = newseq.rot)\n  output\n}\n\n\n\nseq.clust.add <- function(SAPCA,newseq.r){\n  \n  SAPCA.c  <- mclustrev(SAPCA)\n  newseq.c <- mclust::predict.Mclust(SAPCA.c,newseq.r$seq.rot[,SAPCA$call$clusterPCs])\n  newseq.c\n}\n\n\n\nmclustrev <- function(SAPCA){\n  output <- SAPCA$seq.space.clusters$other\n  \n  output$classification <- SAPCA$seq.space.clusters$classification\n  output$G              <- SAPCA$seq.space.clusters$optimal\n  output$z              <- SAPCA$seq.space.clusters$likelihoods\n  \n  class(output) <- \"Mclust\"\n  output\n}\n\n\n\nseq.SAPCA.add <- function (SAPCA,newseq.r,newseq.c){\n  output <- SAPCA\n  output$numerical.alignment$seq.names      <- rownames(newseq.r$seq$MSA)\n  output$numerical.alignment$MSA            <- newseq.r$seq$MSA\n  output$numerical.alignment$MSA.num.wide   <- rbind(newseq.r$seq.num[1,],\n                                                     SAPCA$numerical.alignment$MSA.num.wide)\n  output$numerical.alignment$MSA.scale.wide <- rbind(newseq.r$seq.scale[1,],\n                                                     SAPCA$numerical.alignment$MSA.scale.wide)\n  output$numerical.alignment$MSA.num.stack  <- NULL\n  output$numerical.alignment$MSA.scale.stack<- NULL\n  \n  output$seq.space.PCA$coordinates          <- rbind(newseq.r$seq.rot[1,],\n                                                     SAPCA$seq.space.PCA$coordinates)\n  output$seq.space.clusters$likelihoods     <- rbind(newseq.c$z[1,],\n                                                     SAPCA$seq.space.clusters$likelihoods)\n  output$seq.space.clusters$classification  <- c(newseq.c$classification[1],\n                                                 SAPCA$seq.space.clusters$classification)\n  \n  rownames(output$numerical.alignment$MSA.num.wide)[1]   <- \"query\"\n  rownames(output$numerical.alignment$MSA.scale.wide)[1] <- \"query\"\n  rownames(output$seq.space.PCA$coordinates)[1]          <- \"query\"\n  rownames(output$seq.space.clusters$likelihoods)[1]     <- \"query\"\n  \n  output\n}\n\n\n\nseq.add.full <- function (SAPCA,sequence,SAPCAname=NULL){\n  \n  newseq   <- seq.MSA.add(SAPCA,sequence,SAPCAname)\n  newseq.r <- seq.rotate(SAPCA,newseq)\n  newseq.c <- seq.clust.add(SAPCA,newseq.r)\n  SAPCA2   <- seq.SAPCA.add(SAPCA,newseq.r,newseq.c)\n  \n  SAPCA2\n}\n\n\n\n#BLOSUM40\nblosum <- function(file=\"C:\\\\Users\\\\T\\\\OneDrive\\\\0-Sequences\\\\2-PCA\\\\0-Raw data and scalers\\\\0 - BLOSUM40.csv\"){\n  BLOSUM40 <- read.csv(file)\n  BLOSUM40.names <- BLOSUM40[,1]\n  BLOSUM40 <- BLOSUM40[,-1]\n  BLOSUM40 <- as.matrix(BLOSUM40)\n  rownames(BLOSUM40)<-BLOSUM40.names\n  colnames(BLOSUM40)<-BLOSUM40.names\n  BLOSUM40\n}\n\n\n\npercent <- function(x, digits = 1, format = \"f\", ...) {\n  paste0(formatC(100 * x, format = format, digits = digits, ...), \"%\")\n}\n\n\n\nplot_3Dclusters <- function(SAPCA,\n                            plotPCs    = 1:3,\n                            col        = \"cluster\",\n                            radius     = 1,\n                            labels     = NULL,\n                            write      = FALSE,\n                            axeslabels = \"default\"){\n  if (!is.null(SAPCA$seq.space.PCA$coordinates)){\n    data <- SAPCA$seq.space.PCA$coordinates\n  }else{\n    data <- SAPCA    \n  }\n  \n  if (all(col==\"cluster\")){\n    colour <- SAPCA$seq.space.clusters$classification\n  }else{\n    colour <- col\n  }\n  # Calculate radius size\n  rad <- (range(SAPCA$seq.space.PCA$coordinates[,plotPCs])[2]-range(SAPCA$seq.space.PCA$coordinates[,plotPCs])[1])/100\n  rad <- rad*radius\n  \n  if (all(axeslabels==\"default\")){\n    axes <- paste(\"PC\",plotPCs,sep=\"\")\n  }else{\n    axes <- axeslabels\n  }\n  if (is.null(axeslabels)){\n    axes <- c(\"\",\"\",\"\")\n  }\n  \n  # Plot model-based clusters in 3D\n  rgl::plot3d(data[,plotPCs],\n              col      = colour,      # colour by clusters\n              specular = \"black\",     # matte lighting\n              type     = \"s\",         # \"p\" is points, \"s\" is spheres\n              radius   = rad,         # sphere radius if using spheres\n              size     = 4,           # point size\n              axes     = FALSE,       # draw axes separately\n              xlab     = axes[1],\n              ylab     = axes[2],\n              zlab     = axes[3])       \n  # Draw axes\n  if (write!=FALSE){\n    rgl::axes3d(color = \"black\", labels = FALSE)                       \n  }else{\n    rgl::axes3d(color = \"black\", alpha=0.5, labels = FALSE) \n  }\n  \n  for (NAME in labels){\n    SUB = row.names(SAPCA$seq.space.PCA$coordinates)==NAME      # Label based on its row.name\n    rgl::text3d(subset(SAPCA$seq.space.PCA$coordinates[,plotPCs],subset=SUB), \n                text      = paste('---',NAME),   # data label text\n                font      = 2,                   # bold\n                color     = \"black\",             # colour\n                adj       = -rad/2)              # offset\n  }\n  \n  # Write html for interactive data\n  if (write!=FALSE){\n    rglwidget::.writeWebGL(write)                          \n  }\n}\n\n",
    "created" : 1493613833770.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "979748284",
    "id" : "D540EE12",
    "lastKnownWriteTime" : 1493861559,
    "last_content_update" : 1493861559943,
    "path" : "C:/Users/T/OneDrive/1-Scripts/GitHub/DefSpaceShiny/server.R",
    "project_path" : "server.R",
    "properties" : {
        "docOutlineVisible" : "1"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}