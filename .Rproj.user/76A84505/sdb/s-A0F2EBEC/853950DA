{
    "collab_server" : "",
    "contents" : "#' Calculate a quantitative map of teh sequence space of a multiple sequence alignment\n#'\n#' @param MSA         MSA as a fasta file, matrix of characters, or data frame of characters\n#' @param res.prop    Residue property table as a csv, matrix, or data frame (default = default values for charge, hydrophobicity, R-group molecular weight, disorder propensity, occupancy)\n#' @param clusters    The number of sequence clusters to test for (default = 1:8)\n#' @param clusterPCs  The number of principal components to be used when identifing clusters of sequences (default 5)\n#' @param cys         Whether the sequence is cysteine-rich (default = TRUE)\n#' @param model      Which shapes of clusters to test for (default = \"EII\", \"VII\", \"EEI\", \"VEI\", \"EVI\", \"VVI\", \"EEE\", \"EVE\", \"VEE\", \"VVE\", \"EEV\", \"VEV\", \"EVV\", \"VVV\")\n#'\n#' @return Generates an object of class \"Sequence Alignment Principal Component Analysis\" (SAPCA), providing the scales, numericised matrix generated from the MSA. Data is scaled within each property type. The details of the PAC output components are as follows:\n#' \\itemize{\n#'  \\item {MSA}             {Input MSA as a matrix of characters}\n#'  \\item {res.prop}        {Input residue property table as a data frame}\n#'  \\item {MSA.num.stack}   {Numericised MSA with each property as a separate list item}\n#' }\n#'\n#' @export\n#' @examples\n#' data(example_MSA)\n#' data(residue_properties)\n#' SAPCA <- PCA_MSA(example_MSA,residue_properties)\n#'\n#' @note The `PCA_MSA' function performs multidimensional scaling of a numericised MSA into a reduced space by PCA, to simplify it and aid interpretation.\n#'\n\n#library(\"rgl\")\n#library(\"rglwidget\")\n#library(\"ape\")\n#library(\"ggplot2\")\n#library(\"tidyr\")\n#library(\"seqinr\")\n\n# Main PCA -------\n\nPCA_MSA <- function(MSA,\n                    res.prop,\n                    cys        = TRUE,\n                    clusterPCs = 1:40,\n                    clusters   = 1:15,\n                    model      = \"VVV\",\n                    bootstrap  = NULL,\n                    jackknife  = NULL,\n                    sam        = 0.9,\n                    repPCs     = 3,\n                    correlation= \"pearson\"){\n\n  # for some reason, seem to need to explicitly load this library\n  library(quietly = TRUE,\"mclust\")\n\n\n  ########################.\n  # Perform subfunctions #\n  ########################.\n  MSA       <- read.MSA(MSA = MSA)\n  res.prop  <- read.res.prop(res.prop = res.prop,\n                             cys      = cys)\n  numerical.alignment <- numericise_MSA(MSA      = MSA,\n                                        res.prop = res.prop,\n                                        cys      = cys)\n\n  seq.space.PCA <- rotate_seqspace(numerical.alignment = numerical.alignment)\n\n  # if no replicates\n  if(is.null(bootstrap) && is.null(jackknife)){\n    seq.space.clusters <- find_clusters(seq.space.PCA = seq.space.PCA,\n                                        clusterPCs    = clusterPCs,\n                                        clusters      = clusters,\n                                        model         = model)\n  }\n\n  #if bootstrap replicates\n  if(!is.null(bootstrap)){\n    bootstrap.reps <- bootstrap(MSA,\n                                res.prop   = res.prop,\n                                cys        = cys,\n                                clusterPCs = clusterPCs,\n                                clusters   = clusters,\n                                model      = model,\n                                sam        = sam,\n                                reps       = bootstrap,\n                                PCs        = repPCs,\n                                correlation= correlation)\n    seq.space.clusters <- find_clusters(seq.space.PCA = seq.space.PCA,\n                                        clusterPCs    = clusterPCs,\n                                        clusters      = bootstrap.reps$clust.opt,\n                                        model         = model)\n  }\n\n  #if jackknife replicates\n  if(!is.null(jackknife)){\n    jackknife.reps <- jackknife(MSA,\n                                res.prop   = res.prop,\n                                cys        = cys,\n                                clusterPCs = clusterPCs,\n                                clusters   = clusters,\n                                model      = model,\n                                sam        = sam,\n                                reps       = jackknife,\n                                PCs        = repPCs,\n                                correlation= correlation)\n    seq.space.clusters <- find_clusters(seq.space.PCA = seq.space.PCA,\n                                        clusterPCs    = clusterPCs,\n                                        clusters      = jackknife.reps$clust.opt,\n                                        model         = model)\n  }\n\n  #################.\n  # Format output #\n  #################.\n  output <- list(numerical.alignment = numerical.alignment,\n                 seq.space.PCA       = seq.space.PCA,\n                 seq.space.clusters  = seq.space.clusters,\n                 call                = list(MSA        = MSA,\n                                            res.prop   = res.prop,\n                                            cys        = cys,\n                                            clusterPCs = clusterPCs,\n                                            clusters   = clusters))\n\n  #if replicates have been done, add them to the output\n  if(!is.null(bootstrap)){\n    output$bootstrap.reps   <- bootstrap.reps\n    output$call$bootstrap   <- bootstrap\n    output$call$sam         <- sam\n    output$call$repPCs      <- repPCs\n    output$call$correlation <- correlation\n  }\n  if(!is.null(jackknife)){\n    output$jackknife.reps   <- jackknife.reps\n    output$call$jackknife   <- jackknife\n    output$call$sam         <- sam\n    output$call$repPCs      <- repPCs\n    output$call$correlation <- correlation\n  }\n\n  output\n}\n\n\n\n##################.\n# Numericise MSA #\n##################.\n\nnumericise_MSA <- function(MSA,\n                           res.prop,\n                           cys){\n  seq.names <- rownames(MSA)\n  aln.len   <- ncol(MSA)\n  res.props <- colnames(res.prop)\n  res.avail <- row.names(res.prop)\n  # Numericise MSA based on res.prop\n  MSA.num.tall <- res.prop[t(MSA),]\n  # Name data types\n  rownames(MSA.num.tall) <- NULL\n  sequence     <- rep(x = seq.names, each  = aln.len)\n  residue      <- rep(x = 1:aln.len, times = length(seq.names))\n  MSA.num.tall <- cbind(sequence, residue, MSA.num.tall)\n  # Stack data into list of matrices\n  MSA.num.stack <- NULL\n  for (x in 1:length(res.props)) {\n    col.names <- paste(1:aln.len,\n                       rep(res.props[x],aln.len),\n                       sep = \".\")\n    MSA.num.stack[[res.props[x]]] <- matrix(MSA.num.tall[,x+2],\n                                            ncol     = aln.len,\n                                            byrow    = TRUE,\n                                            dimnames = list(seq.names,\n                                                            col.names))\n  }\n  # Also reflow into single wide matrix\n  MSA.num.wide <- MSA.num.stack[[1]]\n  for (x in 2:length(res.props)) {\n    MSA.num.wide <- cbind(MSA.num.wide, MSA.num.stack[[res.props[x]]])\n  }\n\n\n  ############################.\n  # Scaling by property type #\n  ############################.\n\n  # Take means and variances of each property type\n  prop.means <- NULL\n  prop.vars  <- NULL\n  for (x in 1:length(res.props)) {\n    prop.means[x] <- mean(MSA.num.stack[[x]],na.rm=1)\n    prop.vars[x]  <- var(tidyr::gather(data.frame(MSA.num.stack[[x]]))[2],na.rm=1)\n  }\n  names(prop.means) <- res.props\n  names(prop.vars)  <- res.props\n\n  # Scale numericised MSA to prop.means and prop.vars\n  MSA.scale.stack <- NULL\n  for (x in 1:length(res.props)) {\n    MSA.scale.stack[[res.props[x]]] <- (MSA.num.stack[[res.props[x]]]- prop.means[x]) /\n      sqrt(prop.vars[x])\n  }\n\n  # Replace gaps (currently \"NA\") with column average\n  # Create na.colmean function\n  na.colmean<-function(x){\n    x[is.na(x)] <- mean(as.matrix(x),na.rm = 1)\n    x\n  }\n  # For each property of MSA.num.stack, apply na.colmean function to each matrix comlumn\n  for (x in 1:length(res.props)) {\n    MSA.scale.stack[[x]] <- apply(MSA.scale.stack[[x]],2,na.colmean)\n  }\n\n  # Also reflow into singe wide matrix for PCA\n  MSA.scale.wide <- MSA.scale.stack[[1]]\n  for (x in 2:length(res.props)) {\n    MSA.scale.wide <- cbind(MSA.scale.wide, MSA.scale.stack[[x]])\n  }\n\n\n  ##################.\n  # Alignment list #\n  ##################.\n  numerical.alignment <- list(MSA             = MSA,\n                              res.prop        = res.prop,\n                              MSA.num.stack   = MSA.num.stack,\n                              MSA.num.wide    = MSA.num.wide,\n                              MSA.scale.stack = MSA.scale.stack,\n                              MSA.scale.wide  = MSA.scale.wide,\n                              prop.means      = prop.means,\n                              prop.vars       = prop.vars,\n                              seq.names       = seq.names,\n                              aln.len         = aln.len)\n  numerical.alignment\n}\n\n\n##############################################################.\n# Principal Component analysis of numericised sequence space #\n##############################################################.\n\nrotate_seqspace <- function(numerical.alignment){\n  # Prepare data for PCA\n  toPCA <- numerical.alignment$MSA.scale.wide\n  # If any columns contained gaps only, replace all values with 0\n  toPCA[,is.na(colMeans(toPCA))]<-0\n\n  if (cys==FALSE){\n    toPCA <- toPCA[,grep(\"CYS\", colnames(toPCA), invert = TRUE)]\n  }\n\n  # PCA of data with no extra scaling\n  PCA.raw <- stats::prcomp(toPCA)\n\n  seq.space.PCA <- list(coordinates = PCA.raw$x,\n                        loadings    = PCA.raw$rotation,\n                        centre      = PCA.raw$center,\n                        scale       = PCA.raw$scale,\n                        stdev       = PCA.raw$sdev)\n  seq.space.PCA\n}\n\n\n################################.\n# Finding model-based clusters #\n################################.\n\nfind_clusters <- function(seq.space.PCA,\n                          clusterPCs,\n                          clusters,\n                          model){\n  # Mclust calculating multiple cluster numbsers and chooses most likely\n  # Different model assume different (non-circular) cluster shapes\n  # Different numbers of clusters\n  # Manual - http://www.stat.washington.edu/research/reports/2012/tr597.pdf\n  # model - http://finzi.psych.upenn.edu/R/library/mclust/html/mclustModelNames.html\n\n  if (length(clusterPCs)==1){\n    clusterPCs <- 1:clusterPCs\n  }\n\n  # Using Mclust on PCA data\n  clusters.raw <- mclust::Mclust(seq.space.PCA$coordinates[,clusterPCs], # which PCs to use to find clusters\n                                 prior      = priorControl(),         # starting values for BIC iterations\n                                 G          = clusters,               # number of possible clusters to assess\n                                 modelNames = model)                 # model to test\n\n  clusters.min                <- clusters.raw\n  clusters.min$classification <- NULL\n  clusters.min$G              <- NULL\n  clusters.min$z              <- NULL\n  clusters.min$call           <- NULL\n\n  seq.space.clusters <- list(classification   = clusters.raw$classification,\n                             optimal          = clusters.raw$G,\n                             likelihoods      = clusters.raw$z,\n                             other            = clusters.min)\n  seq.space.clusters\n}\n\n\n################################.\n# Bootstral and jackknife reps #\n################################.\n\nbootstrap <- function(MSA,\n                      res.prop   = res.prop2,\n                      cys        = cys,\n                      clusterPCs = 1:20,\n                      clusters   = 1:15,\n                      model      = \"VVV\",\n                      sam        = 0.9,\n                      reps       = 10,\n                      PCs        = 3,\n                      correlation= \"pearson\"){\n  clust.fit      <- NULL\n  replicates     <- NULL\n  coords         <- NULL\n  coords.cor     <- NULL\n  coords.av.score<- NULL\n\n  print(paste(reps, \"bootstrapped replicates using random\",sam,\"sequence samples\"))\n  for(rep in 1:reps){\n    replicates[[rep]] <- PCA_MSA(MSA=MSA[,sample(ncol(MSA), ncol(MSA)*sam)],\n                                 res.prop   = res.prop,\n                                 clusterPCs = clusterPCs,\n                                 clusters   = clusters,\n                                 model      = model,\n                                 bootstrap  = NULL,\n                                 jackknife  = NULL)\n\n    clust.fit<-rbind(clust.fit,as.vector(replicates[[rep]]$seq.space.clusters$other$BIC))\n\n    for(pc in PCs:1){\n      coords[[pc]]<-cbind(coords[[pc]],replicates[[rep]]$seq.space.PCA$coordinates[,pc])\n    }\n    print(paste(\"bootstrap\",rep))\n  }\n  for(pc in PCs:1){\n    coords.cor[[pc]]<-sqrt(cor(coords[[pc]],method=correlation)^2)\n    diag(coords.cor[[pc]])<-NA\n    coords.av.score[[pc]]<-mean(coords.cor[[pc]],na.rm = TRUE)\n  }\n\n  clust.opt <- which(colMeans(clust.fit)==max(colMeans(clust.fit)))\n  score <- mean(coords.av.score)\n\n  list(replicates = replicates,\n       clust.fit  = clust.fit,\n       clust.opt  = clust.opt,\n       PC.scores  = coords.av.score,\n       score      = score)\n}\n\njackknife <- function(MSA,\n                      res.prop   = res.prop2,\n                      cys        = cys,\n                      clusterPCs = 1:20,\n                      clusters   = 1:15,\n                      model      = \"VVV\",\n                      sam        = 0.9,\n                      reps       = 10,\n                      PCs        = 3,\n                      correlation= \"pearson\"){\n  clust.fit     <- NULL\n  replicates    <- NULL\n  loads         <- NULL\n  loads.cor     <- NULL\n  loads.av.score<- NULL\n\n  print(paste(reps, \"jackknifed replicates using random\",sam,\"column samples\"))\n  for(rep in 1:reps){\n    replicates[[rep]] <- PCA_MSA(MSA=MSA[sample(nrow(MSA), nrow(MSA)*sam),],\n                                 res.prop   = res.prop,\n                                 clusterPCs = clusterPCs,\n                                 clusters   = clusters,\n                                 model      = model,\n                                 bootstrap  = NULL,\n                                 jackknife  = NULL)\n\n    clust.fit<-rbind(clust.fit,as.vector(replicates[[rep]]$seq.space.clusters$other$BIC))\n\n    for(pc in PCs:1){\n      loads[[pc]]<-cbind(loads[[pc]],replicates[[rep]]$seq.space.PCA$loadings[,pc])\n    }\n    print(paste(\"jackknife\",rep))\n  }\n\n  for(pc in PCs:1){\n    loads.cor[[pc]]<-sqrt(cor(loads[[pc]],method=correlation)^2)\n    diag(loads.cor[[pc]])<-NA\n    loads.av.score[[pc]]<-mean(loads.cor[[pc]],na.rm = TRUE)\n  }\n\n  clust.opt <- which(colMeans(clust.fit)==max(colMeans(clust.fit)))\n  score<-mean(loads.av.score)\n\n  list(replicates = replicates,\n       clust.fit  = clust.fit,\n       clust.opt  = clust.opt,\n       PC.scores  = loads.av.score,\n       score      = score)\n}\n\n\n\nsubPCA_MSA <- function(SAPCA,\n                       cluster       = 1,\n                       subclusterPCs = 5,\n                       subclusters   = 1:15,\n                       model         = \"VVV\",\n                       res.prop      = \"inherit\",\n                       cys           = \"inherit\",\n                       bootstrap     = NULL,\n                       jackknife     = NULL,\n                       sam           = 0.9,\n                       repPCs        = 3,\n                       correlation   = \"pearson\"){\n\n  #################.\n  # Define subset #\n  #################.\n\n  # Define subset for graph\n  SUB = SAPCA$seq.space.clusters$classification==cluster\n  #labels$M.AA.type.pc10.8Gs==1|2|3\n\n  ###########################.\n  # SUBSET PCA and clusters #\n  ###########################.\n\n  # Prepare data for PCA\n  toPCA <- subset(SAPCA$numerical.alignment$MSA, subset = SUB)\n\n  if(all(res.prop==\"inherit\")){\n    res.prop <- SAPCA$numerical.alignment$res.prop\n  }\n  if(all(cys==\"inherit\")){\n    cys <- SAPCA$call$cys\n  }\n\n  # PCA the subsetted data inclluding scaling\n  subPCA <- PCA_MSA(MSA         = toPCA,\n                    res.prop    = res.prop,\n                    cys         = cys,\n                    clusterPCs  = subclusterPCs,\n                    clusters    = subclusters,\n                    model       = model,\n                    bootstrap   = bootstrap,\n                    jackknife   = jackknife,\n                    sam         = sam,\n                    repPCs      = repPCs,\n                    correlation = correlation)\n  subPCA\n}\n\n\n# Analysis -------\n\ntopload <- function(SAPCA,\n                    PC = 1,\n                    n  = 20){\n\n  names     <- do.call(rbind, strsplit(gsub(\"\\\\.\",\":\",rownames(SAPCA$seq.space.PCA$loadings)), ':'))\n  consensus <- seqinr::consensus(SAPCA$numerical.alignment$MSA)\n  combined  <- cbind(consensus,names,SAPCA$seq.space.PCA$loadings[,PC])\n  sorted    <- combined[order(sqrt(SAPCA$seq.space.PCA$loadings[,PC]^2),decreasing = TRUE),]\n  rownames(sorted) <- NULL\n  colnames(sorted) <- c(\"consensus\",\"resn\",\"property\",paste(\"PC\",PC,\"_load\",sep=\"\"))\n  if (n==\"all\") {\n    sorted\n  }else{\n    head(sorted,n)\n  }\n}\n\n\nloadingtable <- function(SAPCA,\n                         PC        = 1,\n                         seq       = seqinr::consensus(SAPCA$numerical.alignment$MSA),\n                         magnitude = FALSE){\n\n  input <- SAPCA$seq.space.PCA$loadings[,PC]\n\n  if (magnitude==TRUE){\n    input <- sqrt(input^2)\n  }\n\n  data <- matrix(data     = input,\n                 nrow     = length(colnames(SAPCA$numerical.alignment$res.prop)),\n                 byrow    = TRUE,\n                 dimnames = list(colnames(SAPCA$numerical.alignment$res.prop),\n                                   1:SAPCA$numerical.alignment$aln.len))\n  sum             <- colSums(data)\n  data2           <- rbind(data,sum)\n  colnames(data2) <- paste(1:length(seq), \"(\", seq, \")\", sep=\"\")\n\n  list(data       = data,\n       annotated  = data2)\n}\n\n\nclosest <- function (SAPCA,\n                     sequence,\n                     PC = 1:3,\n                     n  = 10){\n\n  coords     <- SAPCA$seq.space.PCA$coordinates\n  centre     <- coords[sequence,PC]\n  centre.m   <- matrix(rep(centre,nrow(coords)),\n                       nrow  = nrow(coords),\n                       byrow = TRUE)\n  distances  <- SAPCA$seq.space.PCA$coordinates[,PC]-centre.m\n  rootsquare <- sqrt(rowSums(distances^2))\n\n  sorted     <- as.matrix(rootsquare[order(rootsquare)])\n  colnames(sorted) <- \"distance\"\n\n  head(sorted,n)\n}\n\n\ndistance_matrix <- function (SAPCA,\n                             PC     = 1:3,\n                             subset = NULL){\n\n  if (all(is.null(subset))){\n    subset <- 1:nrow(SAPCA$seq.space.PCA$coordinates)\n  }\n\n  coords   <- SAPCA$seq.space.PCA$coordinates[subset,]\n  output  <- NULL\n\n  for (sequence in rownames(coords)) {\n    centre     <- coords[sequence,PC]\n    centre.m   <- matrix(rep(centre,nrow(coords)),\n                         nrow  = nrow(coords),\n                         byrow = TRUE)\n    distances  <- coords[,PC]-centre.m\n    rootsquare <- as.matrix(sqrt(rowSums(distances^2)))\n    colnames(rootsquare) <- sequence\n    output    <- cbind(output,rootsquare)\n  }\n\n  output\n}\n\n\n\nPyMol_columns <- function (SAPCA,\n                           template,\n                           PC=1,\n                           write=FALSE){\n  # Which columns of the template are not gaps\n  structural <- SAPCA$numerical.alignment$MSA[template,]!=\"-\"\n\n  # For the temaplte columns, tabulate the residue loadings for the elected PC\n  output <- 0*loadingtable(SAPCA)$data[,structural]\n  for(i in PC){\n    output <- output + loadingtable(SAPCA,PC = i,magnitude = T)$data[,structural]\n  }\n  output <- rbind(10*output,10*colSums(output),SAPCA$numerical.alignment$MSA[template,structural])\n  if (write!=FALSE){\n    filename <- paste(name,\".Structureloadings\",\".PC\",PC,\".(\",template,\").csv\", sep=\"\")\n    if (write!=TRUE){filename <- write}\n    write.csv(t(output),filename)\n  }\n  output\n}\n\n\n# Adding sequences -------\n\nseq.MSA.add <- function(SAPCA,\n                        sequence,\n                        SAPCAname=NULL){\n  sequence <- casefold(sequence,upper=TRUE)\n  MSA   <- SAPCA$numerical.alignment$MSA\n  MSA2  <- as.AAstringSet(MSA,degap = TRUE)\n  seqs  <- nrow(MSA)\n  seq   <- as.AAstring(sequence, degap=FALSE)\n  seq.d <- as.AAstring(sequence, degap=TRUE)\n  BLOSUM40 <- read.blosum()\n\n  aln.all <- Biostrings::pairwiseAlignment(MSA2,\n                                           seq.d,\n                                           substitutionMatrix = BLOSUM40,\n                                           gapOpening   = 0,\n                                           gapExtension = 8,\n                                           scoreOnly    = TRUE)\n\n  # Max possible similarity score\n  aln.limit <- Biostrings::pairwiseAlignment(seq.d,\n                                             seq.d,\n                                             substitutionMatrix = BLOSUM40,\n                                             gapOpening   = 0,\n                                             gapExtension = 8,\n                                             scoreOnly    = TRUE)\n\n  # Similarity score as percentage of max\n  aln.hit.score <- max(aln.all)/aln.limit\n\n  # The sequence of the best matching member of the database\n  aln.hit.num  <- which(aln.all==max(aln.all))[1]\n  aln.hit.name <- SAPCA$numerical.alignment$seq.names[aln.hit.num]\n  aln.hit.seq  <- paste(as.AAstring(MSA[aln.hit.num,],degap = 1))\n\n  # Use \"*\" to indicate gaps in the best reference sequence (aln.hit)\n  aln.hit <- gsub(\"-\",\"O\",as.AAstring(MSA[aln.hit.num,]))\n  tomsa   <- as.AAstringSet(rbind(as.character(aln.hit),\n                                  as.character(seq.d)),\n                            degap=TRUE)\n  aln.add <- msa(tomsa,\n                 substitutionMatrix = BLOSUM40,\n                 gapOpening   = 0,\n                 gapExtension = 1)\n\n  # Has the new sequence introduced exrta gaps into the hit sequence alignement?\n  aln.hit.orig         <- as.AAstring(MSA[aln.hit.num,])\n  aln.hit.new          <- as.AAstring(as.character(aln.add)[1])\n  aln.hit.seq.aln.orig <- unlist(strsplit(as.character(aln.hit.orig),\"\"))\n  aln.hit.seq.aln.new  <- unlist(strsplit(as.character(aln.hit.new),\"\"))\n\n  if(as.character(aln.hit.orig)!=as.character(aln.hit.new)){\n    print(paste(sum(aln.hit.seq.aln.new==\"-\"),\n                \"residues ofthe new sequence were not alignable to the\",\n                SAPCAname,\n                \"reference MSA so have been ignored\"))\n  }\n\n  # Alignment addition as matrix\n  aln.add.mat <- unlist(as.matrix(aln.add),\"\")\n\n  # Unmatchable resiues removed from aligned sequence\n  aln.add2 <- aln.add.mat[2,][aln.add.mat[1,]!=\"-\"]\n  aln.add3 <- paste(as.AAstring(aln.add2))\n\n  # Gaps in the hit sequence (original and newly aligned)\n  gaps.orig       <- unlist(strsplit(as.character(aln.hit.orig),\"[A-Z]\"))\n  gaps.count.orig <- nchar(gaps.orig)\n  gaps.lead.orig  <- gaps.count.orig[1]\n  gaps.trail.orig <- gaps.count.orig[length(gaps.count.orig)]\n\n  gaps.new        <- unlist(strsplit(as.character(gsub(\"-\",\"\",aln.hit.new)),\"[^O]\"))\n  gaps.count.new  <- nchar(gaps.new)\n  gaps.lead.new   <- gaps.count.new[1]\n  gaps.trail.new  <- gaps.count.new[length(gaps.count.new)]\n\n  if(length(gaps.count.orig)>length(gaps.count.new)){\n    gaps.count.new <- append(gaps.count.new,0)\n  }\n\n  gaps.discrep     <- suppressWarnings(rbind(gaps.count.orig,gaps.count.new))\n  gaps.discrep.num <- gaps.discrep[1,]-gaps.discrep[2,]\n  gaps.lead.add    <- gaps.discrep.num[1]\n  gaps.trail.add   <- gaps.discrep.num[length(gaps.discrep.num)]\n\n  # New alignment\n  aln.add4  <- c(rep(\"-\",gaps.lead.add),\n                 aln.add2,\n                 rep(\"-\",gaps.trail.add))\n\n  original      <- as.character(seq.d)\n  alignable     <- aln.add3\n  \n  tomsa2 <- as.AAstringSet(rbind(original,\n                                 alignable),\n                           degap=TRUE)\n \n   seq.alignable <- msa::msa(tomsa2,\n                             substitutionMatrix = BLOSUM40,\n                             gapOpening   = 0,\n                             gapExtension = 1)\n  length(aln.add4)==ncol(MSA)\n\n  query     <- aln.add4\n\n  aln.final <- rbind(query,MSA)\n  output    <- list(MSA             = aln.final,\n                    aln.hit.name    = aln.hit.name,\n                    aln.hit.seq     = aln.hit.seq,\n                    aln.hit.score   = aln.hit.score,\n                    aln.all.score   = aln.all/aln.limit,\n                    seq.alignable   = seq.alignable)\n  output\n}\n\n\n\nseq.rotate <- function(SAPCA,newseq){\n\n  res.props  <- colnames(SAPCA$numerical.alignment$res.prop)\n  prop.means <- SAPCA$numerical.alignment$prop.means\n  prop.vars  <- SAPCA$numerical.alignment$prop.vars\n  # Align new sequence with MSA\n\n  # Numericise new sequence\n  newseq.num <- numericise_MSA(MSA      = newseq$MSA[c(\"query\",newseq$aln.hit.name),],\n                               res.prop = SAPCA$numerical.alignment$res.prop)\n\n  # Scale new sequnce using same scaling as SAPCA (gaps as \"NA\")\n  newseq.scale.stack <- NULL\n  for (x in 1:length(res.props)) {\n    newseq.scale.stack[[res.props[x]]] <- (newseq.num$MSA.num.stack[[res.props[x]]]- prop.means[x]) /\n      sqrt(prop.vars[x])\n  }\n\n  # Reflow into single wide matrix\n  newseq.scale.wide <- newseq.scale.stack[[1]]\n  for (x in 2:length(res.props)) {\n    newseq.scale.wide <- cbind(newseq.scale.wide, newseq.scale.stack[[res.props[x]]])\n  }\n\n  # Replace gaps (currently \"NA\") with column average of the scaled SAPCA\n  # Create na.colmean function\n  gapvalues  <- colMeans(SAPCA$numerical.alignment$MSA.scale.wide)\n  na.replace <- function(x,y){\n    x[is.na(x)] <- y\n    x\n  }\n  newseq.scale.wide.g <- NULL\n  for(i in 1:ncol(newseq.scale.wide)){\n    newseq.scale.wide.g <- cbind(newseq.scale.wide.g,\n                                 na.replace(newseq.scale.wide[,i],gapvalues[i]))\n  }\n\n  # Rotate scaled sequence into same space as SAPCA\n  newseq.rot <- scale(newseq.scale.wide.g,\n                      SAPCA$seq.space.PCA$centre,\n                      SAPCA$seq.space.PCA$scale) %*% SAPCA$seq.space.PCA$loadings\n\n  # Output\n  output <- list(seq       = newseq,\n                 seq.num   = newseq.num$MSA.num.wide,\n                 seq.scale = newseq.scale.wide.g,\n                 seq.rot   = newseq.rot)\n  output\n}\n\n\n\nseq.clust.add <- function(SAPCA,newseq.r){\n\n  SAPCA.c  <- mclustrev(SAPCA)\n  newseq.c <- mclust::predict.Mclust(SAPCA.c,newseq.r$seq.rot[,SAPCA$call$clusterPCs])\n  newseq.c\n}\n\n\n\nmclustrev <- function(SAPCA){\n  output <- SAPCA$seq.space.clusters$other\n\n  output$classification <- SAPCA$seq.space.clusters$classification\n  output$G              <- SAPCA$seq.space.clusters$optimal\n  output$z              <- SAPCA$seq.space.clusters$likelihoods\n\n  class(output) <- \"Mclust\"\n  output\n}\n\n\n\nseq.SAPCA.add <- function (SAPCA,newseq.r,newseq.c){\n  output <- SAPCA\n  output$numerical.alignment$seq.names      <- rownames(newseq.r$seq$MSA)\n  output$numerical.alignment$MSA            <- newseq.r$seq$MSA\n  output$numerical.alignment$MSA.num.wide   <- rbind(newseq.r$seq.num[1,],\n                                                     SAPCA$numerical.alignment$MSA.num.wide)\n  output$numerical.alignment$MSA.scale.wide <- rbind(newseq.r$seq.scale[1,],\n                                                     SAPCA$numerical.alignment$MSA.scale.wide)\n  output$numerical.alignment$MSA.num.stack  <- NULL\n  output$numerical.alignment$MSA.scale.stack<- NULL\n\n  output$seq.space.PCA$coordinates          <- rbind(newseq.r$seq.rot[1,],\n                                                     SAPCA$seq.space.PCA$coordinates)\n  output$seq.space.clusters$likelihoods     <- rbind(newseq.c$z[1,],\n                                                     SAPCA$seq.space.clusters$likelihoods)\n  output$seq.space.clusters$classification  <- c(newseq.c$classification[1],\n                                                 SAPCA$seq.space.clusters$classification)\n\n  rownames(output$numerical.alignment$MSA.num.wide)[1]   <- \"query\"\n  rownames(output$numerical.alignment$MSA.scale.wide)[1] <- \"query\"\n  rownames(output$seq.space.PCA$coordinates)[1]          <- \"query\"\n  rownames(output$seq.space.clusters$likelihoods)[1]     <- \"query\"\n\n  output\n}\n\n\n\nseq.add.full <- function (SAPCA,sequence,SAPCAname=NULL){\n  sequence <- casefold(sequence,upper=TRUE)\n  newseq   <- seq.MSA.add(SAPCA,sequence,SAPCAname)\n  newseq.r <- seq.rotate(SAPCA,newseq)\n  newseq.c <- seq.clust.add(SAPCA,newseq.r)\n  SAPCA2   <- seq.SAPCA.add(SAPCA,newseq.r,newseq.c)\n\n  SAPCA2\n}\n\n\n# Input/output --------\n\n###############.\n# Prepare MSA #\n###############.\n\nread.MSA <- function(MSA){\n  # Load sequence MSA\n  # if a matrix, can be used straight away\n  # if raw fasta file, use seqinr to convert to data frame\n  if (!is.matrix(MSA)){\n    MSA       <- data.frame(seqinr::read.fasta(MSA,set.attributes=FALSE))\n  }\n  # if a data frame, convert to matrix\n  if (is.data.frame(MSA)){\n    MSA       <- as.matrix(t(toupper(as.matrix(MSA))))\n  }\n\n  MSA\n}\n\n##############################.\n# Prepare residue properties #\n##############################.\n\nread.res.prop <- function(res.prop, cys=TRUE){\n  # Load residue properties\n  # if a data frame, can be used straight away\n  # if a matrix, convert to data frame\n  if (is.matrix(res.prop)){\n    res.prop <- data.frame(res.prop)\n  }\n  # if a csv file, convert to data frame\n  if (!is.data.frame(res.prop)){\n    res.prop <- read.csv(res.prop)\n  }\n  if (all(row.names(res.prop)==1:nrow(res.prop))){\n    # Format rownames and order\n    row.names(res.prop) <- c(as.matrix(res.prop[,1]))           # first column to row names\n    res.prop            <- res.prop[,-1]                        # remove original first column\n    res.prop            <- res.prop[,order(colnames(res.prop))] # order columns alphabetically\n    # Append X and gap rows (if X not already defined)\n    if (length(grep(\"X\", rownames(res.prop)))==0){\n      res.prop          <- rbind(res.prop, colMeans(res.prop))\n      rownames(res.prop)[nrow(res.prop)] <- \"X\"\n    }\n    res.prop            <- rbind(res.prop, rep(NA,ncol(res.prop)))\n    rownames(res.prop)[nrow(res.prop)]   <- \"-\"\n    # Add cystene columns (gaps = 0)\n    if (cys==TRUE){\n      res.prop[ncol(res.prop)+1]                    <- 0\n      colnames(res.prop)[ncol(res.prop)]            <- \"CYS\"\n      res.prop[grep(\"C\", rownames(res.prop)),\"CYS\"] <- 1\n    }\n    # Append presence/absence columns\n    res.prop[ncol(res.prop)+1]         <- c(rep(1,nrow(res.prop)-1),0)\n    colnames(res.prop)[ncol(res.prop)] <- \"NOTGAP\"\n  }\n  res.prop\n}\n\n\n\nread.blosum <- function(file=\"C:\\\\Users\\\\T\\\\OneDrive\\\\0-Sequences\\\\2-PCA\\\\0-Raw data and scalers\\\\0 - BLOSUM40.csv\"){\n  BLOSUM40 <- read.csv(file)\n  BLOSUM40.names <- BLOSUM40[,1]\n  BLOSUM40 <- BLOSUM40[,-1]\n  BLOSUM40 <- as.matrix(BLOSUM40)\n  rownames(BLOSUM40)<-BLOSUM40.names\n  colnames(BLOSUM40)<-BLOSUM40.names\n  BLOSUM40\n}\n\n\n\nas.fasta <- function(matrix,degap=FALSE,decolgap=FALSE,write=FALSE,name=NULL){\n\n  # Remove empty columns\n  if(decolgap){\n    matrix<-matrix[,colMeans(matrix==\"-\")!=1]\n  }\n\n  # Convert alignment matrix to list of strings\n  names <- paste(\">\",row.names(matrix),sep=\"\")\n  seqs  <- do.call(\"paste\",c(data.frame(matrix),sep=\"\"))\n\n  # If just one sequence, this is how to name it\n  if(is.null(dim(matrix))){\n    names <- \">sequence\"\n    if(!is.null(name)){\n      names <- paste(\">\",name,sep=\"\")\n    }\n    seqs  <- paste(matrix,collapse=\"\")\n  }\n\n  # Degap sequences\n  if (degap){\n    seqs <- gsub(\"-\",\"\",seqs)\n  }\n\n  # Interleave names and sequences\n  ord1 <- 2*(1:length(names))-1\n  ord2 <- 2*(1:length(seqs))\n\n  # Output\n  if (write==FALSE){\n    cat(c(names,seqs)[order(c(ord1,ord2))], sep = \"\\n\")\n  }else{\n    if (!grepl(\".fa\",write,ignore.case=TRUE)){\n      write<-paste(write,\".fa\",sep=\"\")\n    }\n    cat(c(names,seqs)[order(c(ord1,ord2))], sep = \"\\n\", file = write)\n  }\n}\n\n\n\nas.AAstring<-function(string, degap=FALSE){\n  string <- paste(string,collapse=\"\")\n  if(degap==TRUE){\n    string<-gsub(\"-\",\"\",string)\n  }\n  output <- Biostrings::AAString(string)\n  output\n}\n\n\n\nas.AAstringSet<-function(MSA, degap=FALSE){\n  MSA <- apply(MSA,1,paste,collapse=\"\")\n  if(degap==TRUE){\n    MSA<-gsub(\"-\",\"\",MSA)\n  }\n  output <- Biostrings::AAStringSet(MSA)\n  output\n}\n\n\n\npercent <- function(x, digits = 1, format = \"f\", ...) {\n  paste0(formatC(100 * x, format = format, digits = digits, ...), \"%\")\n}\n\n\n",
    "created" : 1494385265439.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3390817172",
    "id" : "853950DA",
    "lastKnownWriteTime" : 1508896683,
    "last_content_update" : 1508896683,
    "path" : "C:/Users/T/OneDrive/1-Scripts/GitHub/SeqSpace/SeqSpace main function.R",
    "project_path" : null,
    "properties" : {
        "docOutlineVisible" : "1"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}