{
    "collab_server" : "",
    "contents" : "#########.\n# PLOTS #\n#########.\n\n# Basic plots ---------\n\nplot_modelfit <- function(SAPCA,top=0.001,legend=TRUE){\n  # Model plots     \n  if(!is.null(SAPCA$bootstrap.reps)){\n    data    <- as.matrix(colMeans(SAPCA$bootstrap.reps$clust.fit))\n    data.se <- apply(SAPCA$bootstrap.reps$clust.fit, 2, sd, na.rm = 1)/\n               sqrt(nrow(SAPCA$bootstrap.reps$clust.fit))\n    opt     <- SAPCA$bootstrap.reps$clust.opt\n  }\n  if(!is.null(SAPCA$jackknife.reps)){\n    data    <- as.matrix(colMeans(SAPCA$jackknife.reps$clust.fit))\n    data.se <- apply(SAPCA$jackknife.reps$clust.fit, 2, sd, na.rm = 1)/\n               sqrt(nrow(SAPCA$jackknife.reps$clust.fit))\n    opt     <- SAPCA$jackknife.reps$clust.opt\n  }\n  if(is.null(SAPCA$bootstrap.reps) && is.null(SAPCA$jackknife.reps)){\n    data    <- as.matrix(SAPCA$seq.space.clusters$other$BIC)\n    data.se <- NULL\n    opt     <- SAPCA$seq.space.clusters$optimal\n  }\n  \n  optname <- SAPCA$seq.space.clusters$other$modelName\n  optpos  <- which(data==max(data,na.rm = TRUE))\n  opts    <- (data > quantile(data,1-top,na.rm=TRUE))*row(data)\n  opts[opts==0] <- NA\n  labels  <- rep(NA,length(data))\n  if(ncol(data)==1){\n    labels[optpos] <- opt\n  }else{\n    labels[optpos] <- paste(opt,optname)\n    matplot(data[,],\n            type = \"b\",\n            pch  = 1,\n            ylim = c(min(data,na.rm = TRUE),max(data,na.rm = TRUE)*0.9),\n            xlim = c(1,nrow(data)+1),\n            xlab = \"Number of groups\",\n            ylab = \"Goodness of fit\")\n  }\n  \n    plot(data[,],\n          type = \"l\",\n          pch  = 1,\n          ylim = c(min(data,na.rm = TRUE),max(data,na.rm = TRUE)*0.9),\n          xlim = c(1,nrow(data)+1),\n          xlab = \"Number of groups\",\n          ylab = \"Goodness of fit\")\n  \n  if(top>0.001){\n    lines(x=0:(nrow(data)+2),\n          y=rep(quantile(data,1-top,na.rm=TRUE,type=2),nrow(data)+3),\n          lty=3,col=\"red\")\n  }else{\n    lines(x=rep(opt,2),\n          y=c(min(data,na.rm = TRUE)*1.5,max(data,na.rm = TRUE)),\n          lty=3,col=\"red\")\n  }\n  text(x=opts*(!is.na(opts)),y=data*(!is.na(opts)),labels = labels,pos=3)\n  points(x=opts[!is.na(opts)],y=data[!is.na(opts)], col = \"red\",pch=16)\n  if(all(ncol(data)>1,legend==TRUE)){\n    legend(x      = \"bottomright\",\n           legend = colnames(data),\n           col    = 1:ncol(data),\n           ncol   = round(ncol(data)/4+0.5),\n           pch    = 1,\n           bty    = \"n\")\n  }\n  if(!is.null(data.se)){\n    mclust::errorBars(1:length(data),\n                      upper = data + data.se,\n                      lower = data - data.se,\n                      width = 0.04)\n  }\n}\n\n\n\nplot_scree <- function(SAPCA){\n  # Scree plot of component significance\n  barplot(SAPCA$seq.space.PCA$stdev[1:15],               # first 15 principal components\n          xlab = \"Principal component\",        # x label\n          ylab = \"Variance\",                  # y label\n          main = \"Principal components\")      # title\n}\n\n\n\nplot_heatmap <- function(SAPCA,\n                         PC = 1:3){\n  \n  distances <- distance_matrix(SAPCA,PC=PC)\n  heatmap(distances)\n}  \n\n\n\nplot_network <- function(SAPCA,\n                         PC      = 1:3,\n                         toplink = 20,\n                         col     = \"cluster\",\n                         size    = 4){\n  \n  if(all(col==\"cluster\")){\n    colour <- colours[SAPCA$seq.space.clusters$classification]\n  }else{\n    colour <- col\n  }\n\n  distances <- distance_matrix(SAPCA, PC=PC)\n  distances[distances>quantile(distances, prob=toplink/100)] <- 0\n  g <- igraph::graph.adjacency(distances, mode=\"undirected\", diag=FALSE, weighted=TRUE)\n  plot(g,\n       #edge.width   = linewidth*max(E(g)$weight)/E(g)$weight,\n       edge.curved  = 0.2,\n       vertex.size  = size,\n       vertex.label = NA,\n       vertex.color = colour)\n}   \n\n\n\nplot_loadings_matrix <- function(SAPCA,\n                                 PC        = 1,\n                                 topload   = 100,\n                                 magnitude = FALSE,\n                                 occupancy = FALSE){\n  \n  d  <- loadingtable(SAPCA,PC=PC,magnitude=magnitude)$data\n  d[sqrt(d^2) < quantile(sqrt(d^2),prob=1-topload/100)] <- 0\n  \n  if(all(occupancy==FALSE)){\n    occupancy <- NULL\n    div.line  <- data.frame(x=0,y=0,xend=0,yend=0)\n  }else{\n    occupancy <- colMeans(SAPCA$numerical.alignment$MSA.num.stack$NOTGAP)*max(d)*0.8\n    div.line  <- data.frame(x    = 0.5,\n                            y    = nrow(d)+0.5,\n                            xend = ncol(d)+0.5,\n                            yend = nrow(d)+0.5)\n  }\n  \n  d  <- rbind(d,occupancy)\n  md <- reshape2::melt(d)\n  colnames(md) <- c('Property',\"Residue_number\",'Loading')\n  \n  p <-  ggplot2::ggplot(md)                                                                       +\n        ggplot2::geom_tile(ggplot2::aes_string(x=\"Residue_number\", y=\"Property\", fill=\"Loading\")) +\n        ggplot2::scale_x_continuous(expand = c(0, 0))                                             +\n        ggplot2::scale_y_discrete  (expand = c(0, 0))                                             +\n        ggplot2::theme_classic()                                                                  +\n        ggplot2::theme(panel.border = ggplot2::element_rect(colour = \"black\", fill=NA, size=1))   +\n        ggplot2::geom_segment(data=div.line, ggplot2::aes(x,y,xend=xend, yend=yend), size=0)      +\n        ggplot2::scale_fill_gradient2(low      = \"darkred\",\n                                      high     = \"darkblue\",\n                                      mid      = \"white\",\n                                      na.value = \"grey50\")\n  p\n}\n\n\n\nplot_loadings_categories <- function(SAPCA,\n                                     PC      = 1,\n                                     topload = 10){\n\n  md <- reshape2::melt(loadingtable(SAPCA,PC,magnitude=TRUE)$data)\n  colnames(md) <- c('Property',\"Residue_number\",'Loading')\n  \n  md[md$Loading < quantile(md$Loading,prob=1-topload/100),\"Loading\"] <- 0\n  md[md$Loading>0 ,\"Loading\"] <- as.character(md[md$Loading>0 ,\"Property\"])\n  \n  p <-  ggplot2::ggplot(md)                                                                       +\n        ggplot2::geom_tile(ggplot2::aes_string(x=\"Residue_number\", y=\"Property\", fill=\"Loading\")) +\n        ggplot2::scale_x_continuous(expand = c(0, 0))                                             +\n        ggplot2::scale_y_discrete  (expand = c(0, 0))                                             +\n        ggplot2::theme_classic()                                                                  +\n        ggplot2::theme(panel.border = ggplot2::element_rect(colour = \"black\", fill=NA, size=1))   +\n        ggplot2::scale_fill_manual(guide=FALSE,\n                                   values=c(\"white\",\n                                            \"red\",\n                                            \"blue\",\n                                            \"darkgreen\",\n                                            \"purple\",\n                                            \"grey40\"))   \n  p\n}\n\n\n# 3D plots ---------\n\nplot_3Dclusters <- function(SAPCA,\n                            plotPCs    = 1:3,\n                            col        = \"cluster\",\n                            radius     = 1,\n                            labels     = NULL,\n                            labeltext  = NULL,\n                            write      = FALSE,\n                            axeslabels = \"default\"){\n  if(!is.null(SAPCA$seq.space.PCA$coordinates)){\n    data <- SAPCA$seq.space.PCA$coordinates\n  }else{\n    data <- SAPCA    \n  }\n  \n  if(all(col==\"cluster\")){\n    colour <- SAPCA$seq.space.clusters$classification\n  }else{\n    colour <- col\n  }\n  # Calculate radius size\n  rad <- (range(SAPCA$seq.space.PCA$coordinates[,plotPCs])[2] -\n          range(SAPCA$seq.space.PCA$coordinates[,plotPCs])[1]) /\n          120\n  rad <- rad*radius\n  \n  if(all(axeslabels==\"default\")){\n    axes <- paste(\"PC\",plotPCs,sep=\"\")\n  }else{\n    axes <- axeslabels\n  }\n  if(is.null(axeslabels)){\n    axes <- c(\"\",\"\",\"\")\n  }\n    \n  # Plot model-based clusters in 3D\n  rgl::plot3d(data[,plotPCs],\n              col      = colour,      # colour by clusters\n              specular = \"black\",     # matte lighting\n              type     = \"s\",         # \"p\" is points, \"s\" is spheres\n              radius   = rad,         # sphere radius if using spheres\n              size     = 4,           # point size\n              axes     = FALSE,       # draw axes separately\n              xlab     = axes[1],\n              ylab     = axes[2],\n              zlab     = axes[3])       \n  # Draw axes\n  if(write!=FALSE){\n    rgl::axes3d(color = \"black\", labels = FALSE)                       \n  }else{\n    rgl::axes3d(color = \"black\", alpha=0.5, labels = FALSE) \n  }\n  \n  for (NAME in labels){\n    # Which point will be labelled\n    if(is.numeric(labels) | is.logical(labels)){\n      SUB <- NAME    # Label based on its order number\n    }else{\n      SUB <- row.names(SAPCA$seq.space.PCA$coordinates)==NAME  # Label based on its row.name\n    }\n    \n    # What is the label text\n    if(is.null(labeltext)){\n      TEXT <- NAME\n      if(is.numeric(labels) | is.logical(labels)){\n        TEXT <- SAPCA$numerical.alignment$seq.names[NAME]\n      }\n    }else{\n      TEXT <- labeltext[labels==NAME] \n    }\n    \n    rgl::text3d(SAPCA$seq.space.PCA$coordinates[SUB,plotPCs], \n                text      = paste('---',TEXT),   # data label text\n                font      = 2,                   # bold\n                color     = \"black\",             # colour\n                adj       = -rad/2)              # offset\n  }\n  \n  # Write html for interactive data\n  if(write!=FALSE){\n    rgl::writeWebGL(write)                          \n  }\n}\n\n\n\nplot_3Dbiplot <- function(SAPCA,\n                          plotPCs   = 1:3,\n                          col       = \"property\",\n                          radius    = 1,\n                          labels    = NULL,\n                          labeltext = NULL,\n                          write     = FALSE){\n  if(all(col==\"property\")){\n    colour <- NULL\n    for (x in 1:ncol(SAPCA$numerical.alignment$res.prop)){\n      colour <- append(colour,rep(x,SAPCA$numerical.alignment$aln.len))\n    }\n  }else{\n    colour <- col\n  }\n  # Calculate radius size\n  rad <- (range(SAPCA$seq.space.PCA$loadings[,1])[2] - \n          range(SAPCA$seq.space.PCA$loadings[,1])[1]) /\n          100\n  rad <- rad*radius\n  \n  # Plot model-based clusters in 3D\n  rgl::plot3d(SAPCA$seq.space.PCA$loadings[,plotPCs],\n              col      = colour,      # colour by clusters\n              specular = \"black\",     # matte lighting\n              type     = \"s\",         # \"p\" is points, \"s\" is spheres\n              radius   = rad,         # sphere radius if using spheres\n              size     = 4,           # point size\n              axes     = FALSE)       # draw axes separately\n  # Draw axes\n  if(write!=FALSE){\n    rgl::axes3d(color = \"black\", labels = FALSE)                       \n  }else{\n    rgl::axes3d(color = \"black\", alpha=0.5, labels = FALSE) \n  }\n  \n  for (NAME in labels){\n    \n    # Which point will be labelled\n    if(is.numeric(labels) | is.logical(labels)){\n      SUB <- NAME    # Label based on its order number\n    }else{\n      SUB <- row.names(SAPCA$seq.space.PCA$loadings)==NAME  # Label based on its row.name\n    }\n    \n    # What is the label text\n    if(is.null(labeltext)){\n      TEXT <- NAME\n      if(is.numeric(labels) | is.logical(labels)){\n        TEXT <- rownames(SAPCA$seq.space.PCA$loadings)[NAME]\n      }\n    }else{\n      TEXT <- labeltext[labels==NAME]\n    }\n    \n    rgl::text3d(SAPCA$seq.space.PCA$loadings[SUB,plotPCs], \n              text      = paste('---',TEXT),   # data label text\n              font      = 2,                   # bold\n              color     = \"black\",             # colour\n              adj       = -rad/2)              # offset\n  }\n  \n  # Write html for interactive data\n  if(write!=FALSE){\n    rglwidget::.writeWebGL(write)                          \n  }\n}\n\n\n\nplot_3Dclosest <- function(SAPCA,\n                           sequence,\n                           plotPCs    = 1:3,\n                           measurePCs = 1:3,\n                           radius     = 1,\n                           n          = 10,\n                           write      = FALSE,\n                           axeslabels = \"default\"){\n\n  temp <- SAPCA$numerical.alignment$MSA[,1]\n  temp[1:length(temp)]                    <- \"white\"\n  temp[rownames(closest(SAPCA,sequence,PC = measurePCs, n = n))] <- \"red\"\n  temp[sequence]                          <- \"black\"\n\n  plot_3Dclusters(SAPCA,\n                  radius     = radius,\n                  plotPCs    = plotPCs,\n                  labels     = sequence,\n                  col        = temp,\n                  write      = write,\n                  axeslabels = axeslabels)\n}\n\n\n\nplot_3Drotation <- function(write=\"SeqSpace\", axis = c(0,0,1), fps=24, duration=8, loop=TRUE, clean=TRUE){\n  \n  folder <- paste(write, \"3Dplot.rotation\", sep=\".\")\n  dir.create(folder)\n  \n  rgl::movie3d(rgl::spin3d(axis = axis,\n                           rpm  = 25/duration),\n               duration = fps*duration/10,\n               type     = \"gif\",\n               clean    = FALSE,\n               convert  = FALSE,\n               top      = FALSE,\n               dir      = paste(getwd(),folder,sep=\"/\"))\n  \n  frames     <- duration*fps\n  padding    <- if(stringr::str_length(frames)<=3){3}else{stringr::str_length(frames)}\n  framenames <- NULL\n  for(frame in 0:frames){\n    framenames <- append(framenames,paste(folder,\n                                          \"/movie\",\n                                          stringr::str_pad(frame,\n                                                           padding,\n                                                           pad = \"0\"),\n                                          \".png\",sep=\"\"))\n  }\n  \n  # Animation settings\n  animation::ani.options(loop = loop)      # Looping\n  animation::ani.options(interval = 1/fps) # Framerate\n  \n  #Make 100-frame sections\n  sections <- round(frames/100+0.5)\n  sectionnames <- paste(folder,\"/animation_section\",1:sections,\".gif\",sep=\"\")\n  for(section in 1:sections){\n    animation::im.convert(files  = na.exclude(framenames[((section-1)*100)+(1:100)]),\n                          output = sectionnames[section])\n  }\n  # Combine sections to final video\n  animation::im.convert(files  = sectionnames,\n                        output = paste(folder,\".gif\",sep=\"\"))\n  \n  # Clean up\n  unlink(sectionnames)\n  if(clean==TRUE){\n    unlink(folder, recursive = TRUE)\n  }\n}\n\n\n\nplot_overlay_3Dnetwork <- function(SAPCA,\n                                   toplink = 5,\n                                   plotPCs = 1:3,\n                                   netPCs  = \"default\",\n                                   subset  = NULL,\n                                   col     = \"black\",\n                                   alpha   = 0.2,\n                                   lwd     = 1){\n\n  if(all(netPCs==\"default\")){\n    netPCs <- plotPCs\n  }\n  \n  if(all(is.null(subset))){\n    subset <- 1:nrow(SAPCA$seq.space.PCA$coordinates)\n  }\n  \n  distances  <- distance_matrix(SAPCA, PC=netPCs, subset=subset)\n  mat        <- distances<=quantile(distances, prob=toplink/100)\n  list       <- reshape2::melt(mat)[as.vector(mat),]\n  coords     <- SAPCA$seq.space.PCA$coordinates[subset,plotPCs]\n  line.start <- coords[list[,1],]\n  line.end   <- coords[list[,2],]\n  \n  lines.to.add <- matrix(data     = rbind(t(line.start),\n                                          t(line.end)),\n                         ncol     = 3,\n                         byrow    = TRUE,\n                         dimnames = list(c(rbind(rownames(line.start),\n                                                 rownames(line.end))),\n                                         c(\"x\",\"y\",\"z\")))\n  \n  rgl::segments3d(lines.to.add,\n                  col   = col,\n                  alpha = alpha,\n                  lwd   = lwd)\n}\n\n\n\nplot_overlay_3Dtree <- function (SAPCA     = SAPCA,\n                               tree      = \"nj\",\n                               plotPCs   = 1:3,\n                               njPCs     = 1:3,\n                               ancestors = NULL,\n                               col       = \"black\",\n                               alpha     = 0.2,\n                               lwd       = 1){\n\n  #zero-length distances have to be replaces with some positive integer for FastAnc\n  if(all(tree==\"nj\")){\n    dist          <- distance_matrix(SAPCA,PC = njPCs)\n    dist[dist==0] <- min(dist[dist!=0])/10\n    tree          <- ape::nj(dist)\n  }\n  if(is.null(attributes(tree)[[2]])){\n    tree <- ape::read.tree(tree)\n  }\n  \n  names <- tree$tip.label\n  \n  #format coordinates for tips\n  X <- SAPCA$seq.space.PCA$coordinates[names,plotPCs]\n  \n  #if tree  has no edge lengths, then \n  if(is.null(tree$edge.length)){\n    tree$edge.length <- rep(1,nrow(tree$edge))\n  }\n  \n  #ancestral node 3d locations\n  if(is.null(ancestors)){ \n    A <- apply(X,\n               2,\n               function(x, tree) phytools::fastAnc(tree, x), \n               tree = tree)\n  }else{\n    A <- ancestors[as.character(1:tree$Nnode + length(tree$tip)),]\n  }\n  \n  #prepare data order\n  x <- y <- z <- matrix(NA, nrow(tree$edge), 2)\n  X <- X[tree$tip.label, ]\n  #format tip locations\n  for (i in 1:length(tree$tip)) {\n    x[tree$edge[, 2] == i, 2] <- X[i, 1]\n    y[tree$edge[, 2] == i, 2] <- X[i, 2]\n    z[tree$edge[, 2] == i, 2] <- X[i, 3]\n  }\n  #format node locations\n  for (i in length(tree$tip) + 1:tree$Nnode) {\n    x[tree$edge[, 1] == i, 1] <- x[tree$edge[, 2] == i, 2] <- A[as.character(i),1]\n    y[tree$edge[, 1] == i, 1] <- y[tree$edge[, 2] == i, 2] <- A[as.character(i),2]\n    z[tree$edge[, 1] == i, 1] <- z[tree$edge[, 2] == i, 2] <- A[as.character(i),3]\n  }\n  \n  # #line colours\n  # tip.colour  <- SAPCA$seq.space.clusters$classification[names]\n  # anc.colour  <- round(phytools::fastAnc(tree2, C),0)\n  # all.colour  <- c(tip.colour,anc.colour)\n  # outer       <- tree$edge[,2]\n  # outer[tree$edge[,1]<=tree$edge[,2]] <- tree$edge[tree$edge[,1]<=tree$edge[,2],1]\n  # line.colour <- all.colour[outer]\n  \n  #format line locations\n  line.start   <- cbind(x[,1],y[,1],z[,1])\n  line.end     <- cbind(x[,2],y[,2],z[,2])\n  lines.to.add <- matrix(data     = rbind(t(line.start),\n                                          t(line.end)),\n                         ncol     = 3,\n                         byrow    = TRUE,\n                         dimnames = list(c(rbind(rownames(line.start),\n                                                 rownames(line.end))),\n                                         c(\"x\",\"y\",\"z\")))\n  \n  #plot phylogeny lines\n  rgl::segments3d(lines.to.add,\n                  col   = col,\n                  alpha = alpha,\n                  lwd   = lwd)\n}\n\n\nplot_overlay_3Dlabel <- function(SAPCA,\n                                 plotPCs = 1:3){\n  selected     <- rgl::select3d()\n  selected.set <- selected(SAPCA$seq.space.PCA$coordinates[,plotPCs])\n  if(sum(selected.set)!=0){\n    as.fasta(SAPCA$numerical.alignment$MSA[selected.set,],\n             decolgap=TRUE)\n    \n    \n    for (NAME in SAPCA$numerical.alignment$seq.names[selected.set]){\n      # Which point will be labelled\n      SUB <- NAME   \n      # What is the label text\n      TEXT <- NAME\n      \n      rad <- (range(SAPCA$seq.space.PCA$coordinates[,plotPCs])[2] -\n              range(SAPCA$seq.space.PCA$coordinates[,plotPCs])[1]) /\n              100\n      \n      rgl::text3d(SAPCA$seq.space.PCA$coordinates[SUB,plotPCs], \n                  text      = paste('---',TEXT),   # data label text\n                  font      = 2,                   # bold\n                  color     = \"black\",             # colour\n                  adj       = -rad/2)              # offset\n    }\n  }\n}\n  ",
    "created" : 1494385272712.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1484317089",
    "id" : "1A2A60A",
    "lastKnownWriteTime" : 1505782179,
    "last_content_update" : 1505782179,
    "path" : "C:/Users/T/OneDrive/1-Scripts/GitHub/SeqSpace/Plots.R",
    "project_path" : null,
    "properties" : {
        "docOutlineVisible" : "1"
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}